{"version":3,"sources":["../src/utils/env.ts","../src/utils/errors.ts","../src/utils/common.ts","../src/utils/plugins.ts","../src/core/scope.ts","../src/core/finalize.ts","../src/core/proxy.ts","../src/core/immerClass.ts","../src/core/current.ts","../src/plugins/patches.ts","../src/plugins/mapset.ts","../src/immer.ts"],"sourcesContent":["/**\n * env.ts - 环境常量和Symbol定义\n *\n * 这个文件定义了immer内部使用的核心Symbol常量。\n * 使用Symbol确保了这些标识符的唯一性，避免与用户代码冲突。\n *\n * 设计原则：\n * - 全局唯一性：使用Symbol.for创建全局Symbol\n * - 语义明确：Symbol名称清晰表达用途\n * - 最小依赖：此文件不应有任何导入依赖\n * - 向后兼容：Symbol名称保持稳定\n *\n * 注意：此文件不应包含任何import语句，确保它可以\n * 被其他模块安全导入而不产生循环依赖。\n */\n\n// 应当没有任何import语句！\n// Should be no imports here!\n\n/**\n * NOTHING - 删除操作的标记值\n *\n * 这是一个特殊的Symbol，用于在producer函数中表示删除操作。\n * 当producer函数返回NOTHING时，表示要删除整个状态。\n *\n * 设计考虑：\n * - 明确的语义：区分\"返回undefined\"和\"删除\"\n * - 类型安全：TypeScript可以正确推导这种特殊情况\n * - 全局一致：使用Symbol.for确保多个immer实例间的一致性\n *\n * 使用场景：\n * 1. 删除数组元素：\n *    produce(arr, draft => {\n *      if (shouldDelete) return nothing\n *    })\n *\n * 2. 条件性删除对象：\n *    produce(obj, draft => {\n *      return shouldExist ? draft : nothing\n *    })\n *\n * 3. 清空状态：\n *    produce(state, () => nothing)\n *\n * 实现细节：\n * - 在最终化阶段，NOTHING会被转换为undefined\n * - 补丁系统会为NOTHING生成相应的删除补丁\n * - 与undefined的区别在于语义和处理方式\n *\n * @type {unique symbol} 确保类型唯一性，避免意外赋值\n */\nexport const NOTHING: unique symbol = Symbol.for(\"immer-nothing\")\n\n/**\n * DRAFTABLE - 可草稿化标记\n *\n * 这个Symbol用于标记类实例可以被immer草稿化。\n * 默认情况下，immer只处理普通对象和数组，类实例\n * 被认为是不可变的。通过添加此标记，可以让immer\n * 将类实例视为可修改的对象。\n *\n * 设计目的：\n * - 扩展支持：让用户自定义类也能享受immer的便利\n * - 明确意图：用户需要明确表示类实例可以被草稿化\n * - 安全性：避免意外修改不应修改的对象\n * - 兼容性：不破坏现有的类实例处理逻辑\n *\n * 使用方法：\n *\n * 1. 静态属性方式：\n *    class MyClass {\n *      static [immerable] = true\n *      constructor(public value: number) {}\n *    }\n *\n * 2. 实例属性方式：\n *    class MyClass {\n *      [immerable] = true\n *      constructor(public value: number) {}\n *    }\n *\n * 3. 原型设置方式：\n *    MyClass.prototype[immerable] = true\n *\n * 处理逻辑：\n * - isDraftable函数会检查此标记来决定是否可草稿化\n * - 标记为draftable的类实例会使用对象的草稿化逻辑\n * - 保持类的原型链和方法可访问性\n *\n * 注意事项：\n * - 类的方法仍然是不可变的，只有属性可以修改\n * - 需要确保类的设计适合不可变更新模式\n * - 某些具有复杂内部状态的类可能不适合草稿化\n *\n * @type {unique symbol} 确保标记的唯一性和类型安全\n */\nexport const DRAFTABLE: unique symbol = Symbol.for(\"immer-draftable\")\n\n/**\n * DRAFT_STATE - 草稿状态存储键\n *\n * 这个Symbol用作草稿对象内部状态信息的存储键。\n * 每个草稿对象都会有一个以此Symbol为键的属性，\n * 存储着管理该草稿所需的所有元数据。\n *\n * 存储的状态信息包括：\n * - base_: 原始对象的引用\n * - copy_: 修改后的副本（懒创建）\n * - modified_: 是否被修改的标记\n * - finalized_: 是否已完成最终化\n * - scope_: 所属的作用域\n * - parent_: 父级草稿状态\n * - assigned_: 已分配属性的跟踪\n *\n * 设计优势：\n * - 隐藏实现：用户看不到这些内部状态\n * - 避免冲突：Symbol键确保不会与用户属性冲突\n * - 快速访问：直接作为对象属性，访问效率高\n * - 类型安全：TypeScript可以正确处理Symbol属性\n *\n * 访问模式：\n * - 内部访问：value[DRAFT_STATE]\n * - 类型守卫：通过检查此属性判断是否为草稿\n * - 状态管理：所有草稿操作都基于此状态信息\n *\n * 安全考虑：\n * - 用户无法意外访问或修改内部状态\n * - 序列化时会自动忽略Symbol属性\n * - 不会影响对象的正常使用和遍历\n *\n * 性能考虑：\n * - 直接属性访问，无额外查找开销\n * - Symbol作为属性键的性能与字符串相当\n * - 避免了WeakMap等额外数据结构的开销\n *\n * @type {unique symbol} 确保键的唯一性，避免属性冲突\n */\nexport const DRAFT_STATE: unique symbol = Symbol.for(\"immer-state\")\n","/**\n * errors.ts - Immer错误处理系统\n *\n * 这个模块实现了immer的统一错误处理机制，具有以下特点：\n *\n * 核心设计理念：\n * - 开发友好：开发环境提供详细错误信息\n * - 生产优化：生产环境最小化代码体积\n * - 中心化管理：所有错误信息统一维护\n * - 类型安全：错误处理的类型化管理\n *\n * 优化策略：\n * - 条件编译：基于NODE_ENV的代码分支\n * - 体积优化：生产环境只保留错误代码\n * - 延迟求值：错误消息的懒加载生成\n * - 在线文档：生产环境提供在线错误说明链接\n */\n\n/**\n * 错误信息数组\n *\n * 这个数组包含了immer所有可能的错误信息。使用数组而不是\n * 对象的好处是可以通过数字索引快速访问，同时支持条件编译。\n *\n * 组织结构：\n * - 错误按功能模块分组\n * - 每个错误有唯一的数字ID\n * - 支持参数化的错误消息\n * - 函数形式的错误支持动态参数\n *\n * 编译优化：\n * - 开发环境：完整的错误信息和调用栈\n * - 生产环境：空数组，减少打包体积\n * - Tree-shaking：未使用的错误信息会被移除\n */\nexport const errors =\n\tprocess.env.NODE_ENV !== \"production\"\n\t\t? [\n\t\t\t\t// 所有错误代码，从0开始编号：\n\n\t\t\t\t/**\n\t\t\t\t * 错误0：插件未加载\n\t\t\t\t * 当尝试使用未启用的插件功能时抛出\n\t\t\t\t *\n\t\t\t\t * 触发场景：\n\t\t\t\t * - 使用Map/Set但未调用enableMapSet()\n\t\t\t\t * - 使用补丁功能但未调用enablePatches()\n\t\t\t\t *\n\t\t\t\t * 解决方案：在应用初始化时调用相应的enable函数\n\t\t\t\t */\n\t\t\t\tfunction(plugin: string) {\n\t\t\t\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t\t\t\t},\n\n\t\t\t\t/**\n\t\t\t\t * 错误1：非草稿化对象\n\t\t\t\t * 当produce接收到无法草稿化的对象时抛出\n\t\t\t\t *\n\t\t\t\t * 可草稿化的类型：\n\t\t\t\t * - 普通对象（plain objects）\n\t\t\t\t * - 数组（arrays）\n\t\t\t\t * - Map和Set（需要启用插件）\n\t\t\t\t * - 标记了[immerable]: true的类实例\n\t\t\t\t *\n\t\t\t\t * 不可草稿化的类型：\n\t\t\t\t * - 基本类型（string, number, boolean等）\n\t\t\t\t * - null和undefined\n\t\t\t\t * - 函数\n\t\t\t\t * - Date、RegExp等内置对象（除非特别处理）\n\t\t\t\t * - 未标记的类实例\n\t\t\t\t */\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t\t\t\t},\n\n\t\t\t\t/**\n\t\t\t\t * 错误2：修改冻结对象\n\t\t\t\t * 当尝试修改已冻结的对象时抛出\n\t\t\t\t *\n\t\t\t\t * 触发场景：\n\t\t\t\t * - 在produce外部修改immer生成的对象\n\t\t\t\t * - 修改手动冻结的对象\n\t\t\t\t * - 尝试修改已完成的草稿\n\t\t\t\t *\n\t\t\t\t * 预防措施：\n\t\t\t\t * - 只在producer函数内修改状态\n\t\t\t\t * - 使用current()获取可检查的快照\n\t\t\t\t * - 确保草稿生命周期的正确管理\n\t\t\t\t */\n\t\t\t\t\"This object has been frozen and should not be mutated\",\n\n\t\t\t\t/**\n\t\t\t\t * 错误3：使用已撤销的代理\n\t\t\t\t * 当使用已撤销的Proxy对象时抛出\n\t\t\t\t *\n\t\t\t\t * 撤销场景：\n\t\t\t\t * - producer函数执行完成后\n\t\t\t\t * - 发生错误导致作用域清理\n\t\t\t\t * - 手动调用finishDraft后\n\t\t\t\t *\n\t\t\t\t * 常见原因：\n\t\t\t\t * - 将草稿对象传递给异步函数\n\t\t\t\t * - 在producer外部保存草稿引用\n\t\t\t\t * - 错误的生命周期管理\n\t\t\t\t *\n\t\t\t\t * 解决方案：\n\t\t\t\t * - 在producer内完成所有同步操作\n\t\t\t\t * - 使用current()获取持久化快照\n\t\t\t\t * - 正确管理createDraft/finishDraft的生命周期\n\t\t\t\t */\n\t\t\t\tfunction(data: any) {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\t\t\t\tdata\n\t\t\t\t\t)\n\t\t\t\t},\n\n\t\t\t\t/**\n\t\t\t\t * 错误4：混合修改模式\n\t\t\t\t * 当producer既修改草稿又返回新值时抛出\n\t\t\t\t *\n\t\t\t\t * Immer支持两种模式，但不能混用：\n\t\t\t\t *\n\t\t\t\t * 1. 修改模式（推荐）：\n\t\t\t\t *    produce(state, draft => {\n\t\t\t\t *      draft.value = newValue  // 修改草稿\n\t\t\t\t *      // 不返回任何值，或返回undefined\n\t\t\t\t *    })\n\t\t\t\t *\n\t\t\t\t * 2. 替换模式：\n\t\t\t\t *    produce(state, draft => {\n\t\t\t\t *      return newCompleteState  // 返回全新状态\n\t\t\t\t *      // 不能修改draft\n\t\t\t\t *    })\n\t\t\t\t *\n\t\t\t\t * 错误示例：\n\t\t\t\t *    produce(state, draft => {\n\t\t\t\t *      draft.value = newValue  // 修改了草稿\n\t\t\t\t *      return newState         // 又返回了新值 - 错误！\n\t\t\t\t *    })\n\t\t\t\t */\n\t\t\t\t\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\n\t\t\t\t/**\n\t\t\t\t * 错误5：循环引用\n\t\t\t\t * 当检测到对象循环引用时抛出\n\t\t\t\t *\n\t\t\t\t * 循环引用场景：\n\t\t\t\t * - 对象直接引用自己\n\t\t\t\t * - 对象间的相互引用\n\t\t\t\t * - 深层嵌套的循环结构\n\t\t\t\t *\n\t\t\t\t * Immer限制：\n\t\t\t\t * - 无法安全处理循环引用的草稿化\n\t\t\t\t * - 避免无限递归和内存泄漏\n\t\t\t\t * - 确保最终化过程的确定性\n\t\t\t\t *\n\t\t\t\t * 解决方案：\n\t\t\t\t * - 重新设计数据结构避免循环引用\n\t\t\t\t * - 使用ID引用代替直接对象引用\n\t\t\t\t * - 扁平化嵌套结构\n\t\t\t\t */\n\t\t\t\t\"Immer forbids circular references\",\n\n\t\t\t\t/**\n\t\t\t\t * 错误6：无效的producer参数\n\t\t\t\t * 当produce的第一或第二个参数不是函数时抛出\n\t\t\t\t *\n\t\t\t\t * 有效调用形式：\n\t\t\t\t * - produce(state, producer)\n\t\t\t\t * - produce(producer) // 柯里化形式\n\t\t\t\t *\n\t\t\t\t * 无效示例：\n\t\t\t\t * - produce(state, \"not a function\")\n\t\t\t\t * - produce(123, producer)\n\t\t\t\t */\n\t\t\t\t\"The first or second argument to `produce` must be a function\",\n\n\t\t\t\t/**\n\t\t\t\t * 错误7：无效的补丁监听器\n\t\t\t\t * 当produce的第三个参数不是函数或undefined时抛出\n\t\t\t\t */\n\t\t\t\t\"The third argument to `produce` must be a function or undefined\",\n\n\t\t\t\t/**\n\t\t\t\t * 错误8：无效的createDraft参数\n\t\t\t\t * 当createDraft接收到无法草稿化的对象时抛出\n\t\t\t\t *\n\t\t\t\t * 参见错误1的说明，createDraft的要求与produce相同\n\t\t\t\t */\n\t\t\t\t\"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\n\t\t\t\t/**\n\t\t\t\t * 错误9：无效的finishDraft参数\n\t\t\t\t * 当finishDraft接收到非草稿对象时抛出\n\t\t\t\t *\n\t\t\t\t * 确保传入的是由createDraft创建的草稿对象\n\t\t\t\t */\n\t\t\t\t\"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\n\t\t\t\t/**\n\t\t\t\t * 错误10：current函数参数错误\n\t\t\t\t * 当current函数接收到非草稿对象时抛出\n\t\t\t\t *\n\t\t\t\t * current函数只能用于草稿对象，用于获取当前状态快照\n\t\t\t\t */\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'current' expects a draft, got: ${thing}`\n\t\t\t\t},\n\n\t\t\t\t/**\n\t\t\t\t * 错误11：禁止defineProperty\n\t\t\t\t * 当尝试在草稿对象上使用Object.defineProperty时抛出\n\t\t\t\t *\n\t\t\t\t * 限制原因：\n\t\t\t\t * - defineProperty的语义复杂，难以正确处理\n\t\t\t\t * - 可能破坏草稿对象的内部状态\n\t\t\t\t * - 与Proxy的交互可能产生意外行为\n\t\t\t\t *\n\t\t\t\t * 替代方案：\n\t\t\t\t * - 使用直接赋值：draft.prop = value\n\t\t\t\t * - 在原始对象上预定义属性\n\t\t\t\t */\n\t\t\t\t\"Object.defineProperty() cannot be used on an Immer draft\",\n\n\t\t\t\t/**\n\t\t\t\t * 错误12：禁止setPrototypeOf\n\t\t\t\t * 当尝试在草稿对象上修改原型时抛出\n\t\t\t\t *\n\t\t\t\t * 限制原因：\n\t\t\t\t * - 原型修改会影响对象的基本行为\n\t\t\t\t * - 可能破坏草稿系统的假设\n\t\t\t\t * - 性能和安全考虑\n\t\t\t\t *\n\t\t\t\t * 替代方案：\n\t\t\t\t * - 在创建对象时设置正确的原型\n\t\t\t\t * - 使用Object.create指定原型\n\t\t\t\t */\n\t\t\t\t\"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\n\t\t\t\t/**\n\t\t\t\t * 错误13：数组索引删除限制\n\t\t\t\t * 当尝试删除非数字索引的数组属性时抛出\n\t\t\t\t *\n\t\t\t\t * 限制原因：\n\t\t\t\t * - 数组应该只通过数字索引操作\n\t\t\t\t * - 保持数组语义的一致性\n\t\t\t\t * - 避免将数组当作对象使用\n\t\t\t\t *\n\t\t\t\t * 正确做法：\n\t\t\t\t * - 使用splice删除元素\n\t\t\t\t * - 设置为undefined而不是删除\n\t\t\t\t */\n\t\t\t\t\"Immer only supports deleting array indices\",\n\n\t\t\t\t/**\n\t\t\t\t * 错误14：数组属性设置限制\n\t\t\t\t * 当尝试设置非数字索引或length的数组属性时抛出\n\t\t\t\t *\n\t\t\t\t * 允许的数组操作：\n\t\t\t\t * - 设置数字索引：arr[0] = value\n\t\t\t\t * - 修改长度：arr.length = newLength\n\t\t\t\t *\n\t\t\t\t * 不允许的操作：\n\t\t\t\t * - 设置字符串属性：arr.customProp = value\n\t\t\t\t * - 添加方法：arr.customMethod = function() {}\n\t\t\t\t */\n\t\t\t\t\"Immer only supports setting array indices and the 'length' property\",\n\n\t\t\t\t/**\n\t\t\t\t * 错误15：original函数参数错误\n\t\t\t\t * 当original函数接收到非草稿对象时抛出\n\t\t\t\t *\n\t\t\t\t * original函数用于获取草稿对应的原始对象\n\t\t\t\t */\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'original' expects a draft, got: ${thing}`\n\t\t\t\t}\n\n\t\t\t\t// 注意：如果添加更多错误，需要增加Patches.ts中的errorOffset\n\t\t\t\t// 参见Patches.ts了解额外的错误信息\n\t\t  ]\n\t\t: [] // 生产环境：空数组，减少打包体积\n\n/**\n * die - 统一的错误抛出函数\n *\n * 这是immer内部统一的错误处理入口，根据环境提供不同的错误信息：\n *\n * 开发环境行为：\n * - 获取详细的错误信息\n * - 支持参数化的错误消息\n * - 提供完整的调用栈信息\n * - 帮助开发者快速定位问题\n *\n * 生产环境行为：\n * - 只提供错误代码和在线文档链接\n * - 最小化代码体积\n * - 减少字符串常量占用\n * - 保持基本的错误处理能力\n *\n * 错误信息处理：\n * - 字符串：直接使用\n * - 函数：调用并传入参数，支持动态错误信息\n * - 支持多参数的复杂错误消息构建\n *\n * @param error - 错误代码（对应errors数组的索引）\n * @param args - 传递给错误信息函数的参数\n * @throws {Error} 永远抛出错误，函数不会正常返回\n * @returns {never} TypeScript类型标记，表示函数不会返回\n *\n * 使用示例：\n * - die(0, \"Patches\") // 插件未加载错误\n * - die(1, \"string\") // 非草稿化对象错误\n * - die(2) // 简单的字符串错误\n *\n * 设计优势：\n * - 中心化：所有错误都通过此函数抛出\n * - 一致性：统一的错误格式和前缀\n * - 可配置：基于环境的不同行为\n * - 可扩展：容易添加新的错误类型\n * - 类型安全：never返回类型确保正确的控制流\n */\nexport function die(error: number, ...args: any[]): never {\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\t// 开发环境：提供详细的错误信息\n\t\tconst e = errors[error]\n\t\t// 处理函数式错误信息\n\t\tconst msg = typeof e === \"function\" ? e.apply(null, args as any) : e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\t// 生产环境：最小化错误信息，提供在线文档链接\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","// 导入 immer 内部使用的核心类型和常量\n// 这个文件是 immer 的工具函数集合，提供底层的对象操作和类型判断能力\nimport {\n\tDRAFT_STATE,    // 草稿状态的 Symbol 键，用于标识代理对象\n\tDRAFTABLE,      // 可代理标记 Symbol，用于自定义类的代理支持\n\tObjectish,      // 类对象类型（对象、数组、Map、Set）\n\tDrafted,        // 已代理的草稿对象类型\n\tAnyObject,      // 任意普通对象类型\n\tAnyMap,         // 任意 Map 类型\n\tAnySet,         // 任意 Set 类型\n\tImmerState,     // 草稿对象的内部状态结构\n\tArchType,       // 架构类型枚举（Object/Array/Map/Set）\n\tdie,            // 错误处理函数\n\tStrictMode      // 严格模式配置类型\n} from \"../internal\"\n\n/**\n * 获取对象原型的快捷方式\n * 频繁使用，提取为常量以提升性能和可读性\n */\nexport const getPrototypeOf = Object.getPrototypeOf\n\n/**\n * 判断给定值是否为 Immer 草稿对象\n *\n * 原理：草稿对象都有 DRAFT_STATE 属性，这是 immer 的核心标识\n *\n * 性能优化：\n * - 使用 pure 注释标记为纯函数，支持 tree-shaking\n * - 短路求值：先检查 value 真值性，再检查 DRAFT_STATE\n *\n * @param value 要检查的任意值\n * @returns 如果是草稿对象返回 true，否则返回 false\n */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/**\n * 判断给定值是否可以被 Immer 代理（核心函数）\n *\n * 这是 immer 最重要的判断函数之一，决定了哪些对象可以享受写时复制的特性\n *\n * 可代理对象类型：\n * 1. 普通对象（字面量对象、Object.create(null) 等）\n * 2. 数组（Array 实例）\n * 3. 显式标记的对象（通过 DRAFTABLE symbol）\n * 4. 显式标记的类（构造函数上的 DRAFTABLE）\n * 5. Map 实例（需要 MapSet 插件）\n * 6. Set 实例（需要 MapSet 插件）\n *\n * 设计考虑：\n * - 安全性：只代理可安全操作的对象类型\n * - 性能：避免代理复杂对象（如 DOM 节点、Promise 等）\n * - 可扩展性：通过 DRAFTABLE 支持自定义类\n *\n * @param value 要检查的任意值\n * @returns 如果可以被代理返回 true，否则返回 false\n */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false  // null、undefined、0、\"\"、false 都不可代理\n\treturn (\n\t\tisPlainObject(value) ||           // 普通对象\n\t\tArray.isArray(value) ||           // 数组\n\t\t!!value[DRAFTABLE] ||            // 实例上的可代理标记\n\t\t!!value.constructor?.[DRAFTABLE] || // 构造函数上的可代理标记\n\t\tisMap(value) ||                  // Map（插件支持）\n\t\tisSet(value)                     // Set（插件支持）\n\t)\n}\n\n/**\n * 缓存 Object 构造函数的字符串表示\n * 用于 isPlainObject 中的快速比较，避免重复调用 toString\n */\nconst objectCtorString = Object.prototype.constructor.toString()\n\n/**\n * 判断是否为普通对象（Plain Object）\n *\n * 普通对象定义：\n * 1. 字面量对象：{}\n * 2. Object.create(null) 创建的对象\n * 3. new Object() 创建的对象\n * 4. 原型链简单的对象\n *\n * 非普通对象（不应代理）：\n * - 类实例（除非显式标记）\n * - DOM 节点\n * - 内置对象（Date、RegExp、Promise 等）\n * - 函数对象\n *\n * 算法步骤：\n * 1. 基础类型检查\n * 2. 获取对象原型\n * 3. 处理 null 原型（Object.create(null)）\n * 4. 检查构造函数是否为 Object\n * 5. 通过字符串比较验证构造函数\n *\n * @param value 要检查的值\n * @returns 如果是普通对象返回 true，否则返回 false\n */\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\t// 基础类型检查：非对象或 null 直接返回 false\n\tif (!value || typeof value !== \"object\") return false\n\n\t// 获取对象的原型\n\tconst proto = getPrototypeOf(value)\n\n\t// 处理 Object.create(null) 创建的对象\n\tif (proto === null) {\n\t\treturn true  // 无原型的对象被认为是普通对象\n\t}\n\n\t// 获取原型上的构造函数\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\t// 快速路径：构造函数就是 Object\n\tif (Ctor === Object) return true\n\n\t// 严格验证：通过字符串比较确认构造函数\n\t// 这种方式可以跨 realm/iframe 工作，因为比较的是函数的字符串表示\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/**\n * 获取草稿对象对应的原始对象\n *\n * 用途：\n * 1. 调试时查看原始数据\n * 2. 比较草稿与原始对象的差异\n * 3. 在某些算法中需要访问未修改的原始值\n *\n * 安全性：只能在草稿对象上调用，否则抛出错误\n *\n * @param value 草稿对象\n * @returns 对应的原始对象，如果不是草稿则返回 undefined\n */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(15, value)  // 错误：只能在草稿对象上调用\n\treturn value[DRAFT_STATE].base_      // 返回草稿状态中的原始对象\n}\n\n/**\n * 统一的遍历函数 - 处理不同数据结构的迭代\n *\n * 支持的数据类型：\n * 1. 普通对象 - 遍历所有自有属性（包括不可枚举和 Symbol）\n * 2. 数组 - 按索引遍历\n * 3. Map - 遍历键值对\n * 4. Set - 遍历元素（索引为元素值）\n *\n * 设计优势：\n * - 统一接口：不同数据结构使用相同的遍历方式\n * - 完整性：包括不可枚举属性和 Symbol 属性\n * - 性能：针对不同类型优化的遍历策略\n *\n * @param obj 要遍历的对象\n * @param iter 迭代回调函数 (key, value, source) => void\n */\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void\n): void\nexport function each(obj: any, iter: any) {\n\tif (getArchtype(obj) === ArchType.Object) {\n\t\t// 对象类型：遍历所有自有属性\n\t\t// 使用 Reflect.ownKeys 获取所有属性（包括 Symbol 和不可枚举）\n\t\tReflect.ownKeys(obj).forEach((key) => {\n\t\t\titer(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\t// 集合类型：使用原生的 forEach 方法\n\t\t// 数组、Map、Set 都有 forEach 方法，参数顺序为 (value, key)\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/**\n * 获取对象的架构类型\n *\n * 架构类型是 immer 对数据结构的分类：\n * - Object: 普通对象\n * - Array: 数组\n * - Map: Map 实例\n * - Set: Set 实例\n *\n * 判断优先级：\n * 1. 如果是草稿对象，直接从状态中获取类型\n * 2. 否则通过运行时检查确定类型\n *\n * 性能优化：草稿对象的类型已确定，避免重复检查\n *\n * @param thing 要检查的对象\n * @returns 对应的架构类型枚举值\n */\n/*#__PURE__*/\nexport function getArchtype(thing: any): ArchType {\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_                    // 草稿对象：从状态中直接获取\n\t\t: Array.isArray(thing)          // 非草稿：运行时检查\n\t\t? ArchType.Array\n\t\t: isMap(thing)\n\t\t? ArchType.Map\n\t\t: isSet(thing)\n\t\t? ArchType.Set\n\t\t: ArchType.Object\n}\n\n/**\n * 统一的属性存在性检查\n *\n * 处理不同数据结构的属性检查：\n * - Map: 使用 has() 方法\n * - 其他: 使用 hasOwnProperty 检查\n *\n * 设计考虑：\n * - Map 的 has 检查键的存在性\n * - Object 的 hasOwnProperty 检查自有属性\n * - 统一接口简化上层逻辑\n *\n * @param thing 要检查的对象\n * @param prop 属性键\n * @returns 如果属性存在返回 true，否则返回 false\n */\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === ArchType.Map\n\t\t? thing.has(prop)                                    // Map: 使用原生 has 方法\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)  // Object: 检查自有属性\n}\n\n/**\n * 统一的属性读取函数\n *\n * 处理不同数据结构的属性访问：\n * - Map: 使用 get() 方法\n * - 其他: 使用方括号语法\n *\n * @param thing 要读取的对象\n * @param prop 属性键\n * @returns 属性值\n */\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore - 类型系统限制，运行时是安全的\n\treturn getArchtype(thing) === ArchType.Map ? thing.get(prop) : thing[prop]\n}\n\n/**\n * 统一的属性设置函数\n *\n * 处理不同数据结构的属性写入：\n * - Map: 使用 set(key, value) 方法\n * - Set: 使用 add(value) 方法（忽略 key）\n * - 其他: 使用方括号赋值语法\n *\n * 注意：Set 的语义特殊，只关心值不关心键\n *\n * @param thing 要修改的对象\n * @param propOrOldValue 属性键（对 Set 而言是要删除的旧值）\n * @param value 要设置的值\n */\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === ArchType.Map) thing.set(propOrOldValue, value)      // Map: key-value 设置\n\telse if (t === ArchType.Set) {\n\t\tthing.add(value)                                          // Set: 只添加值\n\t} else thing[propOrOldValue] = value                          // Object: 属性赋值\n}\n\n/**\n * 特殊的相等性判断（Object.is 的兼容实现）\n *\n * 与 === 的区别：\n * 1. NaN === NaN 返回 false，但 is(NaN, NaN) 返回 true\n * 2. +0 === -0 返回 true，但 is(+0, -0) 返回 false\n *\n * 用途：\n * - 准确的值比较，特别是浮点数和 NaN\n * - 检测状态是否真正发生变化\n * - 优化：避免不必要的更新\n *\n * 实现来源：Facebook 的 fbjs 库，经过实战验证\n *\n * @param x 第一个值\n * @param y 第二个值\n * @returns 如果两个值相等返回 true，否则返回 false\n */\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\t// 处理 +0 和 -0 的区别\n\t\t// 1/+0 = +Infinity, 1/-0 = -Infinity\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\t// 处理 NaN 的比较\n\t\t// NaN !== NaN 为 true，所以当 x !== x && y !== y 时，说明都是 NaN\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/**\n * Map 类型检查\n *\n * 简单但重要的类型守卫函数\n * 使用 instanceof 进行准确的类型检查\n *\n * @param target 要检查的值\n * @returns 如果是 Map 实例返回 true，否则返回 false\n */\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn target instanceof Map\n}\n\n/**\n * Set 类型检查\n *\n * 简单但重要的类型守卫函数\n * 使用 instanceof 进行准确的类型检查\n *\n * @param target 要检查的值\n * @returns 如果是 Set 实例返回 true，否则返回 false\n */\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn target instanceof Set\n}\n\n/**\n * 获取草稿状态的最新值\n *\n * 逻辑：\n * - 如果已经有拷贝（copy_），返回拷贝（表示已修改）\n * - 否则返回基础值（base_）（表示未修改）\n *\n * 这是写时复制的核心：只有在真正修改时才创建拷贝\n *\n * @param state 草稿对象的内部状态\n * @returns 当前最新的值（拷贝或原始值）\n */\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/**\n * 浅拷贝函数 - immer 写时复制的核心实现\n *\n * 这是 immer 最关键的函数之一，负责在需要修改时创建对象的浅拷贝\n *\n * 支持的数据类型：\n * 1. Map -> 新的 Map 实例\n * 2. Set -> 新的 Set 实例\n * 3. Array -> slice() 拷贝\n * 4. Object -> 根据严格模式决定拷贝策略\n *\n * 严格模式 (strict) 的影响：\n * - true: 完整拷贝所有属性描述符（getter、setter、可枚举性等）\n * - \"class_only\": 只对非普通对象（类实例）使用严格拷贝\n * - false: 简单拷贝，性能更好但可能丢失属性描述符\n *\n * 性能考虑：\n * - 优先使用原生方法（Map构造函数、Set构造函数、Array.slice）\n * - 对于普通对象，优先使用扩展语法（{...base}）\n * - 严格模式的完整拷贝较慢，仅在必要时使用\n *\n * @param base 要拷贝的原始对象\n * @param strict 严格模式配置\n * @returns 浅拷贝后的新对象\n */\n/*#__PURE__*/\nexport function shallowCopy(base: any, strict: StrictMode) {\n\t// Map 类型：使用构造函数拷贝\n\tif (isMap(base)) {\n\t\treturn new Map(base)\n\t}\n\n\t// Set 类型：使用构造函数拷贝\n\tif (isSet(base)) {\n\t\treturn new Set(base)\n\t}\n\n\t// 数组类型：使用 slice 方法拷贝\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\n\t// 对象类型：根据严格模式选择拷贝策略\n\tconst isPlain = isPlainObject(base)\n\n\tif (strict === true || (strict === \"class_only\" && !isPlain)) {\n\t\t// 严格拷贝模式：完整保留属性描述符\n\n\t\t// 1. 获取所有属性描述符（包括 getter、setter、可枚举性等）\n\t\tconst descriptors = Object.getOwnPropertyDescriptors(base)\n\n\t\t// 2. 移除 DRAFT_STATE 描述符（避免拷贝内部状态）\n\t\tdelete descriptors[DRAFT_STATE as any]\n\n\t\t// 3. 处理所有属性描述符\n\t\tlet keys = Reflect.ownKeys(descriptors)\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tconst key: any = keys[i]\n\t\t\tconst desc = descriptors[key]\n\n\t\t\t// 4. 确保属性可写和可配置（避免拷贝后无法修改）\n\t\t\tif (desc.writable === false) {\n\t\t\t\tdesc.writable = true\n\t\t\t\tdesc.configurable = true\n\t\t\t}\n\n\t\t\t// 5. 特殊处理 getter/setter：转换为普通属性\n\t\t\t// 这样做是为了兼容某些库（如 MobX、Vue）的 trap 行为\n\t\t\t// 与 Object.assign 类似，读取访问器的当前值并转为数据属性\n\t\t\tif (desc.get || desc.set)\n\t\t\t\tdescriptors[key] = {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,     // 也可以用 !!desc.set 来决定是否可写\n\t\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\t\tvalue: base[key]   // 读取当前值，避免 getter 的副作用\n\t\t\t\t}\n\t\t}\n\n\t\t// 6. 使用描述符创建新对象，保持原型链\n\t\treturn Object.create(getPrototypeOf(base), descriptors)\n\t} else {\n\t\t// 普通拷贝模式：性能优先的简单拷贝\n\n\t\tconst proto = getPrototypeOf(base)\n\t\tif (proto !== null && isPlain) {\n\t\t\t// 普通对象优化：使用扩展语法\n\t\t\t// 假设：引擎对扩展语法有更好的内部优化\n\t\t\treturn {...base}\n\t\t}\n\n\t\t// 其他对象：创建同原型的对象并赋值属性\n\t\tconst obj = Object.create(proto)\n\t\treturn Object.assign(obj, base)\n\t}\n}\n\n/**\n * 冻结可草稿化对象\n *\n * 这个函数实现了 immer 的自动冻结功能，确保返回的不可变对象真正不可修改\n *\n * 冻结策略：\n * 1. 跳过已冻结的对象（性能优化）\n * 2. 跳过草稿对象（草稿仍需修改）\n * 3. 跳过不可草稿化对象（如 DOM 节点等）\n * 4. 对 Map/Set 禁用修改方法\n * 5. 使用 Object.freeze 冻结对象\n * 6. 可选的深度冻结\n *\n * 深度冻结的限制：\n * - 只遍历可枚举的字符串属性（性能考虑）\n * - 不冻结 Symbol 属性和不可枚举属性\n * - 参考 issue #590 的讨论\n *\n * @param obj 要冻结的对象\n * @param deep 是否深度冻结（递归冻结嵌套对象）\n * @returns 冻结后的对象（与输入相同）\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\t// 跳过条件：已冻结、是草稿、不可草稿化\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\n\t// 特殊处理：Map 和 Set 的修改方法禁用\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\t// 将修改方法替换为错误函数，保持接口一致但禁止修改\n\t\tobj.set =\n\t\t\tobj.add =\n\t\t\tobj.clear =\n\t\t\tobj.delete =\n\t\t\t\tdontMutateFrozenCollections as any\n\t}\n\n\t// 冻结对象本身\n\tObject.freeze(obj)\n\n\tif (deep)\n\t\t// 深度冻结：递归处理所有值\n\t\t// 注意：只处理 Object.values 返回的可枚举属性\n\t\t// 不处理 Symbol 属性和不可枚举属性（性能考虑）\n\t\tObject.values(obj).forEach((value) => freeze(value, true))\n\n\treturn obj\n}\n\n/**\n * 冻结集合的错误处理函数\n *\n * 当尝试修改已冻结的 Map 或 Set 时，调用此函数抛出错误\n * 提供清晰的错误信息，帮助开发者理解不可变约束\n */\nfunction dontMutateFrozenCollections() {\n\tdie(2)  // 错误代码 2：尝试修改冻结的集合\n}\n\n/**\n * 检查对象是否已冻结\n *\n * 简单包装 Object.isFrozen，提供一致的 API 接口\n *\n * @param obj 要检查的对象\n * @returns 如果对象已冻结返回 true，否则返回 false\n */\nexport function isFrozen(obj: any): boolean {\n\treturn Object.isFrozen(obj)\n}\n","/**\n * plugins.ts - Immer插件系统核心\n *\n * 这个文件实现了immer的插件架构，提供了按需加载功能的机制。\n * 插件系统的设计目标是保持核心的精简，同时支持扩展功能。\n *\n * 核心设计理念：\n * - 按需加载：只有使用的功能才会被包含在最终包中\n * - 类型安全：完整的TypeScript类型支持\n * - 懒加载：插件在首次使用时才进行注册\n * - 扩展性：容易添加新的插件类型\n *\n * 架构优势：\n * - Tree-shaking：未使用的插件不会被打包\n * - 模块化：功能模块可以独立开发和测试\n * - 兼容性：渐进式启用，不破坏现有代码\n * - 性能：避免加载不需要的代码\n */\n\nimport {\n\tImmerState,\n\tPatch,\n\tDrafted,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tArchType,\n\tdie\n} from \"../internal\"\n\n/**\n * 插件注册表\n *\n * 这是一个中心化的插件存储对象，所有已加载的插件都会注册在这里。\n * 使用对象而不是Map是为了更好的类型推导和性能。\n *\n * 插件类型：\n * - Patches: 补丁系统，用于跟踪和应用状态变更\n * - MapSet: Map和Set数据结构支持\n *\n * 设计考虑：\n * - 可选性：所有插件都是可选的，使用 ? 标记\n * - 类型完整：每个插件都有完整的接口定义\n * - 命名一致：插件名称与对应的enable函数一致\n * - 扩展性：添加新插件只需要扩展这个类型\n */\nconst plugins: {\n\t/**\n\t * Patches插件 - 补丁系统\n\t *\n\t * 提供状态变更的跟踪和应用功能，包括：\n\t * - 生成变更补丁\n\t * - 生成替换补丁（用于producer返回新值的情况）\n\t * - 应用补丁到现有状态\n\t *\n\t * 用途：\n\t * - 状态同步：将补丁发送到其他客户端\n\t * - 撤销/重做：使用补丁实现状态历史管理\n\t * - 调试：观察具体的状态变更\n\t * - 持久化：只保存变更而不是完整状态\n\t */\n\tPatches?: {\n\t\t/**\n\t\t * 生成标准补丁\n\t\t * 基于草稿状态的修改记录生成补丁数组\n\t\t */\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,        // 草稿状态对象\n\t\t\tbasePath: PatchPath,      // 当前路径\n\t\t\tpatches: Patch[],         // 正向补丁数组\n\t\t\tinversePatches: Patch[]   // 反向补丁数组\n\t\t): void\n\n\t\t/**\n\t\t * 生成替换补丁\n\t\t * 当producer返回全新对象时生成的补丁\n\t\t */\n\t\tgenerateReplacementPatches_(\n\t\t\tbase: any,                // 原始对象\n\t\t\treplacement: any,         // 替换对象\n\t\t\tpatches: Patch[],         // 正向补丁数组\n\t\t\tinversePatches: Patch[]   // 反向补丁数组\n\t\t): void\n\n\t\t/**\n\t\t * 应用补丁\n\t\t * 将补丁数组应用到目标对象上\n\t\t */\n\t\tapplyPatches_<T>(draft: T, patches: readonly Patch[]): T\n\t}\n\n\t/**\n\t * MapSet插件 - Map和Set支持\n\t *\n\t * 为ES6的Map和Set数据结构提供草稿化支持。\n\t * 由于Map和Set的特殊性质，需要专门的代理实现。\n\t *\n\t * 特殊处理：\n\t * - Map: 键值对的跟踪和修改\n\t * - Set: 值集合的跟踪和修改\n\t * - 插入顺序：保持Map和Set的插入顺序语义\n\t * - 迭代器：正确处理迭代过程中的修改\n\t */\n\tMapSet?: {\n\t\t/**\n\t\t * 创建Map代理\n\t\t * 为Map对象创建可草稿化的代理\n\t\t */\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\n\t\t/**\n\t\t * 创建Set代理\n\t\t * 为Set对象创建可草稿化的代理\n\t\t */\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {} // 初始为空对象，插件会在加载时注册\n\n/**\n * 插件类型定义\n * 从plugins对象推导出的类型，确保类型安全\n */\ntype Plugins = typeof plugins\n\n/**\n * getPlugin - 获取已注册的插件\n *\n * 这是插件系统的核心函数，用于获取已加载的插件实现。\n * 如果插件未加载，会抛出有意义的错误提示用户启用插件。\n *\n * 类型安全：\n * - 使用泛型确保返回类型正确\n * - Exclude类型移除undefined可能性\n * - 编译时检查插件名称的有效性\n *\n * 错误处理：\n * - 清晰的错误信息指导用户如何启用插件\n * - 统一的错误处理机制\n * - 开发环境友好的错误提示\n *\n * @template K - 插件键类型，必须是有效的插件名称\n * @param pluginKey - 要获取的插件名称\n * @returns 对应的插件实现，保证非undefined\n * @throws 如果插件未加载则抛出错误\n *\n * 使用示例：\n * const patches = getPlugin(\"Patches\")\n * patches.generatePatches_(...)\n */\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\t// 抛出友好的错误信息，指导用户如何启用插件\n\t\tdie(0, pluginKey)\n\t}\n\t// @ts-ignore - 我们已经检查了plugin不为空\n\treturn plugin\n}\n\n/**\n * loadPlugin - 加载插件实现\n *\n * 这个函数用于注册插件实现到全局插件注册表中。\n * 通常由插件的enable函数调用，实现懒加载机制。\n *\n * 加载策略：\n * - 幂等性：重复加载同一插件不会产生副作用\n * - 延迟加载：只在首次需要时加载\n * - 类型安全：确保插件实现符合接口要求\n *\n * 设计考虑：\n * - 避免重复：如果插件已加载则跳过\n * - 灵活性：支持插件的热替换（虽然不推荐）\n * - 性能：最小化加载开销\n *\n * @template K - 插件键类型\n * @param pluginKey - 插件名称标识符\n * @param implementation - 插件的具体实现\n *\n * 使用示例：\n * loadPlugin(\"Patches\", {\n *   generatePatches_: ...,\n *   generateReplacementPatches_: ...,\n *   applyPatches_: ...\n * })\n */\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\t// 幂等性检查：如果插件已加载则跳过\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n\n/* ==================== Map/Set插件相关类型 ==================== */\n\n/**\n * MapState - Map对象的草稿状态\n *\n * 继承自ImmerBaseState，添加Map特有的状态管理属性。\n * Map的草稿化需要特殊处理，因为它不能使用标准的属性代理。\n *\n * 状态管理策略：\n * - 延迟拷贝：copy_在首次修改时创建\n * - 修改跟踪：assigned_记录键的修改状态\n * - 撤销支持：revoked_标记代理是否已撤销\n * - 类型标识：type_明确标识为Map类型\n *\n * 特殊属性说明：\n *\n * @property type_ - 架构类型标识，固定为ArchType.Map\n * @property copy_ - Map的修改副本，懒创建以优化性能\n * @property assigned_ - 跟踪键的分配状态，true表示设置，false表示删除\n * @property base_ - 原始Map对象的引用\n * @property revoked_ - 标记代理是否已被撤销\n * @property draft_ - 草稿Map对象本身的引用\n */\nexport interface MapState extends ImmerBaseState {\n\ttype_: ArchType.Map                           // 类型标识\n\tcopy_: AnyMap | undefined                     // 修改副本（懒创建）\n\tassigned_: Map<any, boolean> | undefined      // 键分配跟踪\n\tbase_: AnyMap                                 // 原始Map\n\trevoked_: boolean                             // 撤销状态\n\tdraft_: Drafted<AnyMap, MapState>             // 草稿引用\n}\n\n/**\n * SetState - Set对象的草稿状态\n *\n * 继承自ImmerBaseState，添加Set特有的状态管理属性。\n * Set的草稿化是最复杂的，因为Set中的值可能也需要草稿化。\n *\n * 复杂性来源：\n * - 值草稿化：Set中的对象值可能也需要变为草稿\n * - 引用匹配：需要正确匹配原始值和草稿值\n * - 插入顺序：必须保持Set的插入顺序语义\n * - 唯一性：确保Set中值的唯一性约束\n *\n * 特殊属性说明：\n *\n * @property type_ - 架构类型标识，固定为ArchType.Set\n * @property copy_ - Set的修改副本，包含所有最终值\n * @property base_ - 原始Set对象的引用\n * @property drafts_ - 原始值到草稿值的映射表\n * @property revoked_ - 标记代理是否已被撤销\n * @property draft_ - 草稿Set对象本身的引用\n *\n * drafts_映射表的作用：\n * - 建立原始值与草稿值的对应关系\n * - 确保同一个值在Set中只有一个草稿\n * - 支持has()和delete()操作的正确匹配\n * - 在最终化时正确处理草稿值\n */\nexport interface SetState extends ImmerBaseState {\n\ttype_: ArchType.Set                           // 类型标识\n\tcopy_: AnySet | undefined                     // 修改副本（懒创建）\n\tbase_: AnySet                                 // 原始Set\n\tdrafts_: Map<any, Drafted>                    // 原始值→草稿值映射\n\trevoked_: boolean                             // 撤销状态\n\tdraft_: Drafted<AnySet, SetState>             // 草稿引用\n}\n\n/* ==================== Patches插件相关类型 ==================== */\n\n/**\n * PatchPath - 补丁路径类型\n *\n * 表示补丁操作的目标路径，用于精确定位要修改的属性。\n * 路径是一个数组，每个元素表示一级属性访问。\n *\n * 路径示例：\n * - [] - 根对象\n * - [\"user\"] - obj.user\n * - [\"user\", \"name\"] - obj.user.name\n * - [0] - arr[0]\n * - [\"users\", 0, \"name\"] - obj.users[0].name\n *\n * 类型组成：\n * - string: 对象属性名\n * - number: 数组索引\n *\n * 设计考虑：\n * - 类型安全：明确区分字符串键和数字索引\n * - 序列化友好：可以直接JSON序列化\n * - 简洁性：最小化路径表示的复杂度\n * - 通用性：支持嵌套对象和数组的任意组合\n */\nexport type PatchPath = (string | number)[]\n","// 导入 immer 作用域管理所需的核心类型和工具\nimport {\n\tPatch,         // 补丁对象类型\n\tPatchListener, // 补丁监听器类型\n\tDrafted,       // 已代理的草稿对象类型\n\tImmer,         // Immer 主类\n\tDRAFT_STATE,   // 草稿状态的 Symbol 键\n\tImmerState,    // 草稿对象的内部状态结构\n\tArchType,      // 架构类型枚举\n\tgetPlugin      // 获取插件实现的函数\n} from \"../internal\"\n\n/**\n * ImmerScope 接口 - 表示一次 produce 调用的执行上下文\n *\n * 作用域的核心概念：\n * 1. 隔离性：每次 produce 调用都有独立的执行环境\n * 2. 层次性：支持嵌套 produce 调用，形成作用域栈\n * 3. 生命周期：从 enterScope 到 leaveScope 的完整周期\n * 4. 资源管理：跟踪和清理所有相关资源\n *\n * 设计目的：\n * - 管理嵌套 produce 调用的复杂性\n * - 确保补丁生成的正确性\n * - 优化自动冻结的性能\n * - 提供完整的错误恢复机制\n */\nexport interface ImmerScope {\n\t/**\n\t * 补丁数组 - 记录本次调用产生的所有变更\n\t * 只有当启用补丁功能时才会初始化\n\t * 用于生成从原始状态到新状态的变更记录\n\t */\n\tpatches_?: Patch[]\n\n\t/**\n\t * 逆向补丁数组 - 记录如何撤销本次变更\n\t * 与 patches_ 成对出现，用于实现 undo 功能\n\t * 包含从新状态回到原始状态的操作序列\n\t */\n\tinversePatches_?: Patch[]\n\n\t/**\n\t * 自动冻结控制标志\n\t *\n\t * 设计原理：\n\t * 当修改的草稿包含来自其他作用域的草稿时，需要禁用自动冻结\n\t * 这确保未拥有的草稿可以被正确最终化\n\t *\n\t * 场景示例：\n\t * - 嵌套 produce 调用时的跨作用域引用\n\t * - 手动创建的草稿对象的处理\n\t */\n\tcanAutoFreeze_: boolean\n\n\t/**\n\t * 草稿对象数组 - 当前作用域创建的所有草稿\n\t *\n\t * 用途：\n\t * 1. 生命周期管理：确保所有草稿都能被正确清理\n\t * 2. 最终化处理：在作用域结束时处理所有草稿\n\t * 3. 错误恢复：在异常时撤销所有草稿的修改\n\t * 4. 内存管理：防止草稿对象泄漏\n\t */\n\tdrafts_: any[]\n\n\t/**\n\t * 父级作用域引用 - 形成作用域栈结构\n\t *\n\t * 作用域栈的意义：\n\t * - 支持嵌套的 produce 调用\n\t * - 维护正确的执行上下文\n\t * - 实现作用域的层次化管理\n\t * - 确保资源的正确释放顺序\n\t */\n\tparent_?: ImmerScope\n\n\t/**\n\t * 补丁监听器 - 接收补丁变更通知的回调函数\n\t *\n\t * 监听器的作用：\n\t * - 实时获取状态变更信息\n\t * - 支持自定义的变更处理逻辑\n\t * - 实现状态同步和持久化\n\t * - 提供调试和日志记录能力\n\t */\n\tpatchListener_?: PatchListener\n\n\t/**\n\t * Immer 实例引用 - 关联的 Immer 配置\n\t *\n\t * 重要性：\n\t * - 访问实例特定的配置（autoFreeze、useStrictShallowCopy）\n\t * - 确保使用正确的处理策略\n\t * - 支持多个 Immer 实例的并存\n\t */\n\timmer_: Immer\n\n\t/**\n\t * 未最终化草稿计数器\n\t *\n\t * 计数作用：\n\t * - 跟踪还有多少草稿需要最终化\n\t * - 优化最终化过程的性能\n\t * - 确保所有草稿都得到正确处理\n\t * - 检测潜在的内存泄漏问题\n\t */\n\tunfinalizedDrafts_: number\n}\n\n/**\n * 全局当前作用域指针\n *\n * 设计考虑：\n * - 使用全局变量简化作用域访问\n * - 支持作用域栈的快速切换\n * - 避免在每个函数调用中传递作用域参数\n * - 确保作用域状态的一致性\n *\n * 注意：这种设计要求 immer 的操作是同步的\n */\nlet currentScope: ImmerScope | undefined\n\n/**\n * 获取当前作用域\n *\n * 返回当前活跃的作用域实例\n * 使用断言操作符(!)确保作用域存在，因为只有在 produce 调用内才会访问\n *\n * @returns 当前作用域实例\n */\nexport function getCurrentScope() {\n\treturn currentScope!\n}\n\n/**\n * 创建新的作用域实例\n *\n * 初始化策略：\n * 1. 创建空的草稿数组，准备收集本次调用的草稿\n * 2. 设置父级作用域引用，构建作用域链\n * 3. 关联 Immer 实例，继承配置信息\n * 4. 默认启用自动冻结，除非后续检测到跨作用域引用\n * 5. 初始化未最终化计数器为 0\n *\n * @param parent_ 父级作用域，用于嵌套调用\n * @param immer_ 关联的 Immer 实例\n * @returns 新创建的作用域实例\n */\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],                    // 空数组，准备收集草稿\n\t\tparent_,                        // 父级作用域引用\n\t\timmer_,                         // Immer 实例引用\n\t\t// 自动冻结控制的重要注释：\n\t\t// 当修改的草稿包含来自其他作用域的草稿时，\n\t\t// 需要禁用自动冻结，以便未拥有的草稿可以被正确最终化\n\t\tcanAutoFreeze_: true,           // 默认允许自动冻结\n\t\tunfinalizedDrafts_: 0           // 初始无未最终化草稿\n\t}\n}\n\n/**\n * 在作用域中启用补丁功能\n *\n * 补丁系统的初始化：\n * 1. 验证补丁插件是否已加载\n * 2. 初始化补丁收集数组\n * 3. 设置补丁监听器\n *\n * 设计原理：\n * - 补丁功能是可选的，只有在需要时才启用\n * - 通过插件系统实现，保持核心代码的简洁\n * - 支持自定义的补丁处理逻辑\n *\n * @param scope 要启用补丁功能的作用域\n * @param patchListener 可选的补丁监听器\n */\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // 断言补丁插件已加载\n\t\tscope.patches_ = []           // 初始化正向补丁数组\n\t\tscope.inversePatches_ = []    // 初始化逆向补丁数组\n\t\tscope.patchListener_ = patchListener // 设置监听器\n\t}\n}\n\n/**\n * 撤销作用域 - 错误恢复时的清理操作\n *\n * 撤销流程：\n * 1. 正常离开作用域（更新作用域栈）\n * 2. 撤销所有创建的草稿对象\n * 3. 清空草稿数组，释放内存\n *\n * 使用场景：\n * - recipe 函数抛出异常时\n * - produce 调用被中断时\n * - 需要回滚所有修改时\n *\n * 设计目的：\n * - 确保异常安全性\n * - 防止部分修改的状态泄漏\n * - 恢复对象的原始状态\n *\n * @param scope 要撤销的作用域\n */\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)                    // 先正常离开作用域\n\tscope.drafts_.forEach(revokeDraft)   // 撤销所有草稿对象\n\t// @ts-ignore - 故意设置为 null 以帮助垃圾回收\n\tscope.drafts_ = null\n}\n\n/**\n * 离开作用域 - 正常完成时的清理操作\n *\n * 作用域栈管理：\n * - 只有当前作用域才能被离开\n * - 自动恢复到父级作用域\n * - 维护作用域栈的完整性\n *\n * 调用时机：\n * - produce 函数正常完成时\n * - 手动草稿完成时\n * - 作用域撤销时（作为第一步）\n *\n * @param scope 要离开的作用域\n */\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_     // 恢复到父级作用域\n\t}\n}\n\n/**\n * 进入新作用域 - 开始新的 produce 调用\n *\n * 作用域创建流程：\n * 1. 创建新的作用域实例\n * 2. 设置当前作用域为新创建的作用域\n * 3. 返回作用域实例供后续操作使用\n *\n * 作用域栈的构建：\n * - 新作用域自动链接到当前作用域作为父级\n * - 形成后进先出(LIFO)的栈结构\n * - 支持任意深度的嵌套调用\n *\n * @param immer 关联的 Immer 实例\n * @returns 新创建并激活的作用域\n */\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\n/**\n * 撤销单个草稿对象\n *\n * 撤销策略根据草稿类型分类：\n * 1. 对象和数组：调用代理的 revoke 方法，使代理失效\n * 2. Map 和 Set：设置 revoked 标志，标记为已撤销\n *\n * 撤销的效果：\n * - 对象/数组：代理失效，任何访问都会抛出 TypeError\n * - Map/Set：通过标志位控制，后续操作将被拒绝\n *\n * 设计考虑：\n * - 不同数据类型需要不同的撤销机制\n * - 确保撤销后的对象不能被继续使用\n * - 提供清晰的错误信息帮助调试\n *\n * @param draft 要撤销的草稿对象\n */\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (state.type_ === ArchType.Object || state.type_ === ArchType.Array)\n\t\tstate.revoke_()              // 对象/数组：撤销代理\n\telse state.revoked_ = true       // Map/Set：设置撤销标志\n}\n","/**\n * finalize.ts - 草稿最终化处理模块\n *\n * 这个模块是immer工作流程的最后阶段，负责将producer函数执行完成后的草稿对象\n * 转换为最终的不可变结果。最终化过程包括多个关键步骤：\n *\n * 核心功能：\n * - 处理producer函数的返回值（可能是新对象或修改的草稿）\n * - 递归地最终化所有草稿对象和嵌套属性\n * - 生成变更补丁（patches）用于状态跟踪\n * - 根据配置自动冻结对象以确保不可变性\n * - 清理和撤销作用域资源\n *\n * 性能优化：\n * - 跳过未修改的草稿，直接返回base对象\n * - 避免重复最终化已处理的对象\n * - 智能决定是否需要深度冻结\n * - Set对象的特殊处理避免无限循环\n */\n\nimport {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tArchType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen\n} from \"../internal\"\n\n/**\n * 处理producer函数的执行结果\n *\n * 这是最终化流程的入口函数，负责处理produce调用的各种情况：\n * 1. producer返回undefined：使用修改后的草稿作为结果\n * 2. producer返回新对象：验证并使用返回值作为结果\n * 3. producer返回NOTHING：表示删除操作，最终返回undefined\n *\n * 关键职责：\n * - 检测是否返回了新对象（替换模式）\n * - 验证替换模式下的合法性（草稿不能既被修改又被替换）\n * - 最终化结果对象及其所有嵌套内容\n * - 生成变更补丁记录\n * - 清理作用域资源\n *\n * @param result - producer函数的返回值\n * @param scope - 当前作用域，包含草稿和配置信息\n * @returns 最终化后的不可变结果\n */\nexport function processResult(result: any, scope: ImmerScope) {\n\t// 记录未完成最终化的草稿数量，用于后续优化判断\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\n\t// 获取根草稿对象（producer函数的参数）\n\tconst baseDraft = scope.drafts_![0]\n\n\t// 检测是否是替换模式：producer返回了新对象而不是修改草稿\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\n\tif (isReplaced) {\n\t\t// 替换模式：producer返回了新对象\n\n\t\t// 安全检查：在替换模式下，原草稿不应该被修改\n\t\t// 这防止了混合使用修改和替换模式导致的不一致状态\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4) // 错误：不能既修改草稿又返回新值\n\t\t}\n\n\t\t// 如果返回的是可草稿化的对象，需要递归最终化\n\t\t// 因为返回值可能包含或就是草稿的子集\n\t\tif (isDraftable(result)) {\n\t\t\tresult = finalize(scope, result)\n\t\t\t// 只有根作用域才进行冻结，嵌套作用域的冻结由父级处理\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\n\t\t// 生成替换模式的补丁：记录整个对象被替换\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// 标准模式：最终化修改后的草稿对象\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\n\t// 清理作用域：撤销代理、清理资源\n\trevokeScope(scope)\n\n\t// 触发补丁监听器，通知外部变更\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\n\t// 处理NOTHING标记：表示删除操作，返回undefined\n\treturn result !== NOTHING ? result : undefined\n}\n\n/**\n * 递归最终化草稿对象\n *\n * 这是最终化的核心函数，负责将草稿对象转换为最终的不可变状态。\n * 它会递归处理对象的所有属性，确保嵌套的草稿也被正确最终化。\n *\n * 处理策略：\n * - 已冻结对象：直接返回，避免重复处理\n * - 非草稿对象：递归处理属性，可能包含草稿\n * - 其他作用域的草稿：跳过，避免跨作用域干扰\n * - 未修改的草稿：返回原始base对象\n * - 已修改的草稿：最终化copy对象\n *\n * @param rootScope - 根作用域，用于跟踪整个最终化过程\n * @param value - 要最终化的值（可能是草稿或普通对象）\n * @param path - 用于生成补丁的路径信息（可选）\n * @returns 最终化后的不可变对象\n */\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// 性能优化：跳过已冻结的对象，避免重复处理递归数据结构\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\n\t// 处理普通对象（非草稿），但可能包含草稿属性\n\tif (!state) {\n\t\t// 递归处理所有属性，寻找嵌套的草稿\n\t\teach(value, (key, childValue) =>\n\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path)\n\t\t)\n\t\treturn value\n\t}\n\n\t// 跨作用域保护：只处理当前作用域拥有的草稿\n\t// 这防止了嵌套produce调用时的干扰\n\tif (state.scope_ !== rootScope) return value\n\n\t// 性能优化：未修改的草稿直接返回原始对象\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\n\t// 最终化已修改的草稿\n\tif (!state.finalized_) {\n\t\t// 标记为已最终化，避免重复处理\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\n\t\tconst result = state.copy_\n\n\t\t// Set对象的特殊处理：避免在迭代时修改导致的无限循环\n\t\t// 参见issue #628的详细说明\n\t\tlet resultEach = result\n\t\tlet isSet = false\n\t\tif (state.type_ === ArchType.Set) {\n\t\t\t// 创建Set的副本用于迭代，清空原Set让finalizeProperty重新添加\n\t\t\tresultEach = new Set(result)\n\t\t\tresult.clear()\n\t\t\tisSet = true\n\t\t}\n\n\t\t// 递归最终化所有子属性\n\t\teach(resultEach, (key, childValue) =>\n\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path, isSet)\n\t\t)\n\n\t\t// 所有内容都已最终化，现在可以冻结整个对象\n\t\tmaybeFreeze(rootScope, result, false)\n\n\t\t// 首次最终化时生成变更补丁\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\n\treturn state.copy_\n}\n\n/**\n * 最终化对象的单个属性\n *\n * 这个函数处理对象属性的最终化，是finalize函数的关键辅助函数。\n * 它需要处理各种复杂情况：草稿属性、嵌套对象、Set集合等。\n *\n * 处理逻辑：\n * 1. 草稿属性：递归最终化并更新到目标对象\n * 2. Set集合：特殊的添加方式\n * 3. 可草稿化对象：递归检查嵌套的草稿\n * 4. 性能优化：在特定条件下提前终止递归\n *\n * @param rootScope - 根作用域\n * @param parentState - 父对象的草稿状态（如果是草稿）\n * @param targetObject - 要设置属性的目标对象\n * @param prop - 属性键\n * @param childValue - 属性值\n * @param rootPath - 补丁路径（可选）\n * @param targetIsSet - 目标是否为Set对象\n */\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath,\n\ttargetIsSet?: boolean\n) {\n\t// 开发环境的循环引用检查\n\tif (process.env.NODE_ENV !== \"production\" && childValue === targetObject)\n\t\tdie(5)\n\n\tif (isDraft(childValue)) {\n\t\t// 处理草稿属性\n\n\t\t// 构建补丁路径：只有在特定条件下才需要深度补丁\n\t\t// Set对象是原子的（没有键），跳过已分配的键的深度补丁\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ArchType.Set && // Set对象是原子性的\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // 跳过已分配键的深度补丁\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\n\t\t// 递归最终化草稿属性\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\n\t\t// 嵌套produce检测：如果最终化后仍是草稿，说明在嵌套的produce中\n\t\t// 此时不能自动冻结，因为外层produce可能还需要修改\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t} else if (targetIsSet) {\n\t\t// Set对象的特殊处理：重新添加非草稿值\n\t\ttargetObject.add(childValue)\n\t}\n\n\t// 递归检查新对象中未最终化的草稿\n\t// 冻结的对象永远不应该包含草稿\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\t// 性能优化：在特定条件下提前终止递归\n\t\t// 如果没有自动冻结，且确定没有剩余的草稿，可以停止遍历\n\t\t// 这特别有利于添加大型数据树而无需进一步处理的场景\n\t\t// 参见add-data.js性能测试\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\treturn\n\t\t}\n\n\t\t// 递归最终化嵌套的可草稿化对象\n\t\tfinalize(rootScope, childValue)\n\n\t\t// 深度冻结策略：\n\t\t// - 只有在没有父状态或父状态不是嵌套作用域时才冻结\n\t\t// - 跳过符号属性以避免与其他框架冲突（参见#590）\n\t\t// - 只冻结可枚举属性\n\t\tif (\n\t\t\t(!parentState || !parentState.scope_.parent_) &&\n\t\t\ttypeof prop !== \"symbol\" &&\n\t\t\tObject.prototype.propertyIsEnumerable.call(targetObject, prop)\n\t\t)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\n/**\n * 根据配置决定是否冻结对象\n *\n * 冻结是immer确保不可变性的重要机制，但需要谨慎应用以避免性能问题。\n * 只有在根作用域且配置允许的情况下才进行冻结。\n *\n * 冻结策略：\n * - 只有根作用域才能冻结，避免影响嵌套对象的剪枝优化\n * - 必须开启autoFreeze配置\n * - 必须允许自动冻结（canAutoFreeze_为true）\n *\n * @param scope - 当前作用域\n * @param value - 要冻结的值\n * @param deep - 是否进行深度冻结，默认false\n */\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\t// 冻结条件检查：\n\t// 1. 必须是根作用域（防止影响包装对象内草稿的剪枝）\n\t// 2. 必须开启自动冻结配置\n\t// 3. 必须允许自动冻结（可能被嵌套produce禁用）\n\tif (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","/**\n * proxy.ts - Immer Proxy代理核心实现\n *\n * 这是immer最核心和最复杂的模块，实现了基于ES6 Proxy的草稿化机制。\n * 通过劫持对象的属性访问和修改操作，实现了写时复制和状态跟踪。\n *\n * 核心设计理念：\n * - 透明代理：用户感觉像在直接修改对象\n * - 写时复制：只有在实际修改时才创建副本\n * - 结构共享：未修改的部分继续共享引用\n * - 嵌套支持：自动处理嵌套对象的草稿化\n *\n * 技术特点：\n * - Proxy劫持：拦截所有属性操作\n * - 延迟创建：推迟昂贵操作到真正需要时\n * - 状态跟踪：精确记录哪些属性被修改\n * - 类型保持：保持原对象的类型和行为\n *\n * 架构亮点：\n * - 统一接口：对象和数组使用相同的代理逻辑\n * - 性能优化：多层缓存和快速路径\n * - 错误处理：完善的边界条件处理\n * - 扩展性：支持自定义对象类型\n */\n\nimport {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tgetPrototypeOf,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tArchType,\n\tImmerScope\n} from \"../internal\"\n\n/**\n * ProxyBaseState - Proxy代理状态的基础接口\n *\n * 扩展了ImmerBaseState，添加了Proxy特有的状态管理属性。\n * 这个接口是对象和数组代理状态的共同基础。\n *\n * 关键特性：\n * - 属性跟踪：记录哪些属性被访问和修改\n * - 撤销支持：支持代理的撤销操作\n * - 层次关系：维护父子草稿的关系\n */\ninterface ProxyBaseState extends ImmerBaseState {\n\t/**\n\t * assigned_ - 属性分配跟踪表\n\t *\n\t * 这是Proxy代理的核心数据结构，跟踪每个属性的修改状态：\n\t * - true: 属性被设置了新值\n\t * - false: 属性被删除\n\t * - undefined: 属性未被触碰\n\t *\n\t * 用途：\n\t * - 补丁生成：确定哪些属性需要生成补丁\n\t * - 性能优化：避免不必要的拷贝操作\n\t * - 状态跟踪：支持精确的变更检测\n\t */\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\n\t/**\n\t * parent_ - 父级草稿状态引用\n\t *\n\t * 建立草稿对象的层次关系，支持：\n\t * - 变更冒泡：子对象的修改会标记父对象为已修改\n\t * - 作用域管理：确保所有草稿属于同一作用域\n\t * - 错误恢复：在异常时正确清理整个草稿树\n\t */\n\tparent_?: ImmerState\n\n\t/**\n\t * revoke_ - 代理撤销函数\n\t *\n\t * ES6 Proxy.revocable返回的撤销函数，用于：\n\t * - 生命周期管理：在草稿完成后撤销代理\n\t * - 安全性：防止在错误状态下继续使用代理\n\t * - 内存清理：释放代理相关的资源\n\t * - 错误处理：在异常情况下快速失效代理\n\t */\n\trevoke_(): void\n}\n\n/**\n * ProxyObjectState - 普通对象的代理状态\n *\n * 专门用于普通对象的草稿状态管理，继承了ProxyBaseState\n * 的所有功能，并添加了对象特有的属性。\n *\n * 对象特性：\n * - 属性访问：支持任意字符串键的属性\n * - 动态结构：可以添加和删除属性\n * - 原型链：保持原始对象的原型链\n * - 描述符：处理属性描述符的复制\n */\nexport interface ProxyObjectState extends ProxyBaseState {\n\t/**\n\t * type_ - 架构类型标识\n\t * 固定为ArchType.Object，用于运行时类型识别\n\t */\n\ttype_: ArchType.Object\n\n\t/**\n\t * base_ - 原始对象引用\n\t * 保持对原始对象的引用，用于：\n\t * - 属性继承：从原始对象继承未修改的属性\n\t * - 比较操作：检测是否发生了实际修改\n\t * - 性能优化：避免不必要的属性复制\n\t */\n\tbase_: any\n\n\t/**\n\t * copy_ - 修改副本\n\t * 延迟创建的对象副本，包含所有修改：\n\t * - 懒创建：只在首次修改时创建\n\t * - 写时复制：共享未修改的部分\n\t * - 完整性：包含所有最终的属性值\n\t */\n\tcopy_: any\n\n\t/**\n\t * draft_ - 草稿对象引用\n\t * 指向用户操作的草稿对象（即Proxy本身）\n\t */\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\n/**\n * ProxyArrayState - 数组的代理状态\n *\n * 专门用于数组对象的草稿状态管理。数组在很多方面与对象相似，\n * 但有一些特殊的行为需要处理。\n *\n * 数组特性：\n * - 数字索引：主要通过数字索引访问元素\n * - 长度属性：length属性需要特殊维护\n * - 稀疏性：支持稀疏数组的正确处理\n * - 方法调用：数组方法需要特殊处理\n */\nexport interface ProxyArrayState extends ProxyBaseState {\n\t/**\n\t * type_ - 架构类型标识\n\t * 固定为ArchType.Array，用于数组特有的处理逻辑\n\t */\n\ttype_: ArchType.Array\n\n\t/**\n\t * base_ - 原始数组引用\n\t * 类型明确为AnyArray，确保类型安全\n\t */\n\tbase_: AnyArray\n\n\t/**\n\t * copy_ - 数组副本\n\t * 可能为null，表示尚未创建副本\n\t */\n\tcopy_: AnyArray | null\n\n\t/**\n\t * draft_ - 草稿数组引用\n\t * 指向用户操作的草稿数组\n\t */\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\n/**\n * ProxyState - 代理状态联合类型\n *\n * 将对象和数组的代理状态统一为一个类型，\n * 便于编写通用的处理逻辑。\n */\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * createProxyProxy - 创建Proxy代理草稿\n *\n * 这是创建草稿对象的核心函数，通过ES6 Proxy实现对象的草稿化。\n * 它会根据对象类型选择合适的代理策略，并建立完整的状态管理。\n *\n * 工作流程：\n * 1. 检测对象类型（对象vs数组）\n * 2. 创建状态对象，包含所有必要的元数据\n * 3. 选择合适的代理陷阱处理器\n * 4. 创建可撤销的Proxy对象\n * 5. 建立双向引用关系\n *\n * 设计亮点：\n * - 类型检测：自动识别对象和数组\n * - 状态管理：完整的生命周期管理\n * - 性能优化：延迟创建和智能缓存\n * - 错误处理：撤销机制和异常安全\n *\n * @template T - 原始对象的类型\n * @param base - 要代理的原始对象\n * @param parent - 父级草稿状态（用于嵌套对象）\n * @returns 草稿化的代理对象\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\t// 类型检测：区分数组和普通对象\n\tconst isArray = Array.isArray(base)\n\n\t// 创建代理状态对象\n\tconst state: ProxyState = {\n\t\t// 类型标识：数组或对象\n\t\ttype_: isArray ? ArchType.Array : (ArchType.Object as any),\n\n\t\t// 作用域管理：继承父级作用域或使用当前作用域\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\n\t\t// 修改标记：初始为false，表示未修改\n\t\tmodified_: false,\n\n\t\t// 最终化标记：用于最终化过程的控制\n\t\tfinalized_: false,\n\n\t\t// 属性分配跟踪：记录哪些属性被设置或删除\n\t\tassigned_: {},\n\n\t\t// 父级状态：建立层次关系\n\t\tparent_: parent,\n\n\t\t// 原始对象：保持引用用于比较和继承\n\t\tbase_: base,\n\n\t\t// 草稿引用：稍后设置\n\t\tdraft_: null as any,\n\n\t\t// 修改副本：延迟创建\n\t\tcopy_: null,\n\n\t\t// 撤销函数：稍后设置\n\t\trevoke_: null as any,\n\n\t\t// 手动标记：false表示自动管理\n\t\tisManual_: false\n\t}\n\n\t// Proxy需要一个目标对象，但我们也需要能够从目标确定相关的状态\n\t// （为了避免为每个实例创建陷阱来捕获闭包中的状态，\n\t// 以及避免创建奇怪的隐藏属性）\n\t// 所以技巧是使用'state'作为实际的'target'！（并确保我们拦截一切）\n\t// 注意：对于数组，我们将状态放在数组中以获得更好的默认Reflect行为\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\n\tif (isArray) {\n\t\t// 数组特殊处理：将状态包装在数组中\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\t// 创建可撤销的Proxy\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\n\t// 建立双向引用\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\n\treturn proxy as any\n}\n\n/**\n * objectTraps - 对象代理陷阱处理器\n *\n * 这是Proxy的核心，定义了如何拦截和处理对象的各种操作。\n * 每个陷阱函数都实现了特定的代理逻辑，确保草稿化的正确性。\n *\n * 设计原则：\n * - 透明性：对用户完全透明，像操作普通对象\n * - 延迟性：只在需要时执行昂贵操作\n * - 一致性：保持JavaScript语义的一致性\n * - 性能：优化常见操作的执行路径\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\t/**\n\t * get陷阱 - 属性访问拦截\n\t *\n\t * 这是最复杂和最重要的陷阱，处理所有的属性访问。\n\t * 它需要处理多种情况：现有属性、新属性、嵌套对象等。\n\t *\n\t * 处理逻辑：\n\t * 1. 特殊属性：DRAFT_STATE直接返回状态\n\t * 2. 现有属性：从最新状态获取值\n\t * 3. 不存在属性：从原型链查找\n\t * 4. 可草稿化值：自动创建嵌套草稿\n\t * 5. 普通值：直接返回\n\t *\n\t * 性能优化：\n\t * - 快速路径：已最终化的对象直接返回值\n\t * - 缓存机制：避免重复创建嵌套草稿\n\t * - 延迟拷贝：只在实际修改时创建副本\n\t */\n\tget(state, prop) {\n\t\t// 特殊属性：返回草稿状态\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\t// 获取最新状态（可能是base或copy）\n\t\tconst source = latest(state)\n\n\t\t// 属性不存在：从原型链查找\n\t\tif (!has(source, prop)) {\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\n\t\tconst value = source[prop]\n\n\t\t// 快速路径：已最终化或不可草稿化的值直接返回\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\n\t\t// 检查是否需要创建嵌套草稿\n\t\t// 如果值与base中的相同，说明这是第一次访问，需要创建草稿\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\t// 准备副本（如果还没有的话）\n\t\t\tprepareCopy(state)\n\t\t\t// 创建嵌套草稿并缓存\n\t\t\treturn (state.copy_![prop as any] = createProxy(value, state))\n\t\t}\n\n\t\t// 值已经被修改过，直接返回\n\t\treturn value\n\t},\n\n\t/**\n\t * has陷阱 - 属性存在性检查\n\t *\n\t * 处理 'prop' in object 操作，检查属性是否存在。\n\t * 简单地委托给最新状态的检查。\n\t */\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\n\t/**\n\t * ownKeys陷阱 - 自有属性枚举\n\t *\n\t * 处理 Object.keys()、Object.getOwnPropertyNames() 等操作。\n\t * 返回最新状态的所有自有属性键。\n\t */\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\n\t/**\n\t * set陷阱 - 属性设置拦截\n\t *\n\t * 这是实现写时复制的核心陷阱，处理所有的属性赋值操作。\n\t * 它需要检测是否真的发生了变化，并相应地更新状态。\n\t *\n\t * 复杂性来源：\n\t * - 属性描述符：处理getter/setter属性\n\t * - 变化检测：区分真实变化和重复赋值\n\t * - 状态管理：更新修改标记和分配记录\n\t * - 性能优化：避免不必要的拷贝操作\n\t *\n\t * 处理流程：\n\t * 1. 检查属性描述符，处理setter\n\t * 2. 检测是否为真实的变化\n\t * 3. 处理特殊情况（草稿赋值、相同值等）\n\t * 4. 创建副本并更新状态\n\t * 5. 标记修改并更新分配记录\n\t */\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* 严格来说不是，但有助于TS类型推导 */,\n\t\tvalue\n\t) {\n\t\t// 检查属性描述符，特别是setter\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// 特殊情况：如果有setter，需要用正确的上下文调用\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\n\t\t// 性能优化：检查是否真的需要修改\n\t\tif (!state.modified_) {\n\t\t\t// 获取当前值进行比较\n\t\t\tconst current = peek(latest(state), prop)\n\n\t\t\t// 特殊情况：如果赋值的是草稿的原始值，可以忽略赋值\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\n\t\t\t// 值相同检查：如果值没有变化，直接返回\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\n\t\t\t// 准备修改：创建副本并标记修改\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\t// 重复赋值检查：避免设置相同的值\n\t\tif (\n\t\t\t(state.copy_![prop] === value &&\n\t\t\t\t// 特殊情况：处理值为undefined的新属性\n\t\t\t\t(value !== undefined || prop in state.copy_)) ||\n\t\t\t// 特殊情况：NaN的处理\n\t\t\t(Number.isNaN(value) && Number.isNaN(state.copy_![prop]))\n\t\t)\n\t\t\treturn true\n\n\t\t// 执行实际的赋值操作\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\n\t/**\n\t * deleteProperty陷阱 - 属性删除拦截\n\t *\n\t * 处理 delete object.prop 操作。需要区分删除现有属性\n\t * 和删除不存在的属性，并正确更新状态。\n\t *\n\t * 处理逻辑：\n\t * 1. 检查属性是否在原始对象中存在\n\t * 2. 标记为删除（assigned_[prop] = false）\n\t * 3. 准备副本并标记修改\n\t * 4. 从副本中删除属性\n\t */\n\tdeleteProperty(state, prop: string) {\n\t\t// 检查属性是否存在（undefined检查是快速路径）\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\t// 标记为删除\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// 如果是原本就不存在的属性，删除分配记录\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\n\t\t// 从副本中删除\n\t\tif (state.copy_) {\n\t\t\tdelete state.copy_[prop]\n\t\t}\n\t\treturn true\n\t},\n\n\t/**\n\t * getOwnPropertyDescriptor陷阱 - 属性描述符获取\n\t *\n\t * 处理 Object.getOwnPropertyDescriptor() 操作。\n\t * 注意：我们不会将desc.value强制转换为Immer草稿，\n\t * 因为在ES5模式下无法做出同样的保证。\n\t */\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\n\t\treturn {\n\t\t\twritable: true,\n\t\t\t// 数组的length属性不可配置\n\t\t\tconfigurable: state.type_ !== ArchType.Array || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\n\t/**\n\t * defineProperty陷阱 - 属性定义拦截\n\t *\n\t * 禁止在草稿上使用Object.defineProperty()，\n\t * 因为这会使草稿系统变得复杂且难以预测。\n\t */\n\tdefineProperty() {\n\t\tdie(11) // 抛出错误：不允许defineProperty\n\t},\n\n\t/**\n\t * getPrototypeOf陷阱 - 原型获取\n\t *\n\t * 返回原始对象的原型，保持原型链的一致性。\n\t */\n\tgetPrototypeOf(state) {\n\t\treturn getPrototypeOf(state.base_)\n\t},\n\n\t/**\n\t * setPrototypeOf陷阱 - 原型设置拦截\n\t *\n\t * 禁止修改草稿对象的原型，因为这会影响对象的基本行为。\n\t */\n\tsetPrototypeOf() {\n\t\tdie(12) // 抛出错误：不允许setPrototypeOf\n\t}\n}\n\n/**\n * arrayTraps - 数组代理陷阱处理器\n *\n * 数组的代理处理基本上继承对象的处理逻辑，但需要一些特殊调整。\n * 主要差异在于数组的target是[state]而不是state本身。\n *\n * 实现策略：\n * - 复用逻辑：大部分陷阱直接复用objectTraps\n * - 参数调整：将arguments[0]从[state]调整为state\n * - 特殊处理：delete和set操作有数组特有的逻辑\n */\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\n\n// 复制对象陷阱，但调整第一个参数\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\t// 将[state]调整为state\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\n\n/**\n * 数组删除操作的特殊处理\n *\n * 数组只应该删除数字索引，删除其他属性会导致错误。\n * 实际上，数组的删除会转换为设置undefined。\n */\narrayTraps.deleteProperty = function(state, prop) {\n\t// 开发环境检查：只允许删除数字索引\n\tif (process.env.NODE_ENV !== \"production\" && isNaN(parseInt(prop as any)))\n\t\tdie(13)\n\n\t// 将删除转换为设置undefined\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\n\n/**\n * 数组设置操作的特殊处理\n *\n * 数组只应该设置数字索引和length属性，其他操作会导致错误。\n */\narrayTraps.set = function(state, prop, value) {\n\t// 开发环境检查：只允许设置数字索引和length\n\tif (\n\t\tprocess.env.NODE_ENV !== \"production\" &&\n\t\tprop !== \"length\" &&\n\t\tisNaN(parseInt(prop as any))\n\t)\n\t\tdie(14)\n\n\t// 委托给对象的set处理\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n/* ==================== 辅助函数 ==================== */\n\n/**\n * peek - 无副作用的属性访问\n *\n * 访问草稿的属性而不创建嵌套草稿。主要用于比较操作。\n *\n * @param draft - 草稿对象\n * @param prop - 属性键\n * @returns 属性值（不会是草稿）\n */\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\n/**\n * readPropFromProto - 从原型链读取属性\n *\n * 当属性不存在于对象自身时，从原型链查找。\n * 特别处理getter属性，确保正确的this绑定。\n *\n * @param state - 草稿状态\n * @param source - 源对象\n * @param prop - 属性键\n * @returns 属性值或undefined\n */\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // 特殊情况：如果是原型定义的getter，需要用草稿作为上下文调用\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\n/**\n * getDescriptorFromProto - 从原型链获取属性描述符\n *\n * 沿着原型链查找属性描述符，用于处理继承的属性。\n *\n * @param source - 源对象\n * @param prop - 属性键\n * @returns 属性描述符或undefined\n */\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in'检查包括原型链\n\tif (!(prop in source)) return undefined\n\n\tlet proto = getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\n/**\n * markChanged - 标记草稿为已修改\n *\n * 递归地标记草稿及其所有父级为已修改状态。\n * 这确保了变更会正确地冒泡到根级别。\n *\n * @param state - 要标记的草稿状态\n */\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\t// 递归标记父级\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\n/**\n * prepareCopy - 准备对象副本\n *\n * 延迟创建对象的副本，只在真正需要修改时才执行。\n * 这是写时复制策略的核心实现。\n *\n * @param state - 需要副本的状态对象\n */\nexport function prepareCopy(state: {\n\tbase_: any\n\tcopy_: any\n\tscope_: ImmerScope\n}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(\n\t\t\tstate.base_,\n\t\t\tstate.scope_.immer_.useStrictShallowCopy_\n\t\t)\n\t}\n}\n","// 导入所有必需的类型定义和工具函数\n// 这些导入展现了 immer 的模块化设计，每个模块负责特定功能\nimport {\n\tIProduceWithPatches,    // 带补丁的 produce 接口类型\n\tIProduce,               // 标准 produce 接口类型\n\tImmerState,             // 草稿对象的内部状态结构\n\tDrafted,                // 已代理的草稿对象类型\n\tisDraftable,            // 判断对象是否可被代理\n\tprocessResult,          // 处理 recipe 函数的返回结果\n\tPatch,                  // 补丁对象类型\n\tObjectish,              // 类对象类型（对象、数组、Map、Set）\n\tDRAFT_STATE,            // 草稿状态的 Symbol 键\n\tDraft,                  // 草稿类型定义\n\tPatchListener,          // 补丁监听器类型\n\tisDraft,                // 判断是否为草稿对象\n\tisMap,                  // 判断是否为 Map 类型\n\tisSet,                  // 判断是否为 Set 类型\n\tcreateProxyProxy,       // 创建普通对象/数组的代理\n\tgetPlugin,              // 获取插件实现\n\tdie,                    // 错误处理函数\n\tenterScope,             // 进入新的执行作用域\n\trevokeScope,            // 撤销作用域（错误时）\n\tleaveScope,             // 正常离开作用域\n\tusePatchesInScope,      // 在作用域中使用补丁功能\n\tgetCurrentScope,        // 获取当前执行作用域\n\tNOTHING,                // 表示删除操作的特殊符号\n\tfreeze,                 // 冻结对象函数\n\tcurrent                 // 获取草稿当前状态快照\n} from \"../internal\"\n\n/**\n * 生产者函数接口\n * 定义了 Immer 类必须实现的核心方法\n */\ninterface ProducersFns {\n\tproduce: IProduce                    // 标准的 produce 方法\n\tproduceWithPatches: IProduceWithPatches  // 带补丁信息的 produce 方法\n}\n\n/**\n * 严格模式类型定义\n * - true: 对所有对象启用严格浅拷贝\n * - false: 使用默认拷贝策略\n * - \"class_only\": 仅对类实例启用严格拷贝\n */\nexport type StrictMode = boolean | \"class_only\";\n\n/**\n * Immer 核心类 - 不可变数据处理的协调中心\n *\n * 职责：\n * 1. 管理全局配置（自动冻结、严格拷贝等）\n * 2. 协调作用域、代理、最终化等各个模块\n * 3. 提供所有对外 API 的具体实现\n * 4. 处理不同使用模式（标准调用、柯里化、手动草稿等）\n */\nexport class Immer implements ProducersFns {\n\t/**\n\t * 自动冻结配置\n\t * true: 自动冻结所有生成的不可变对象（默认）\n\t * false: 不自动冻结，提升性能但降低安全性\n\t */\n\tautoFreeze_: boolean = true\n\n\t/**\n\t * 严格浅拷贝配置\n\t * 控制是否拷贝对象的属性描述符（getter、setter、可枚举性等）\n\t */\n\tuseStrictShallowCopy_: StrictMode = false\n\n\t/**\n\t * 构造函数 - 初始化 Immer 实例\n\t * @param config 可选的配置对象\n\t */\n\tconstructor(config?: {\n\t\tautoFreeze?: boolean\n\t\tuseStrictShallowCopy?: StrictMode\n\t}) {\n\t\t// 配置自动冻结选项\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t\t// 配置严格浅拷贝选项\n\t\tif (typeof config?.useStrictShallowCopy === \"boolean\")\n\t\t\tthis.setUseStrictShallowCopy(config!.useStrictShallowCopy)\n\t}\n\n\t/**\n\t * 🎯 核心方法：produce - 创建不可变副本\n\t *\n\t * 这是 immer 最重要的方法，实现了写时复制的核心逻辑\n\t *\n\t * 工作流程：\n\t * 1. 处理柯里化调用模式\n\t * 2. 验证参数合法性\n\t * 3. 判断是否需要创建代理（isDraftable）\n\t * 4. 创建执行作用域和代理对象\n\t * 5. 执行用户的 recipe 函数\n\t * 6. 处理异常和清理工作\n\t * 7. 生成最终的不可变结果\n\t *\n\t * @param base 基础状态对象\n\t * @param recipe 修改函数，接收草稿对象并进行修改\n\t * @param patchListener 可选的补丁监听器\n\t * @returns 新的不可变状态，如果没有修改则返回原对象\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// 🔄 处理柯里化调用：produce(recipe) 或 produce(recipe, defaultBase)\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe  // 第二个参数作为默认基础状态\n\t\t\trecipe = base              // 第一个参数作为 recipe 函数\n\n\t\t\tconst self = this\n\t\t\t// 返回柯里化的生产者函数\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,    // 使用默认基础状态\n\t\t\t\t...args: any[]         // 额外参数传递给 recipe\n\t\t\t) {\n\t\t\t\t// 递归调用标准 produce，并正确绑定 this 上下文\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args))\n\t\t\t}\n\t\t}\n\n\t\t// 📋 参数验证\n\t\tif (typeof recipe !== \"function\") die(6)  // recipe 必须是函数\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)  // 补丁监听器必须是函数或 undefined\n\n\t\tlet result\n\n\t\t// 🎯 核心逻辑分支：处理可代理对象\n\t\tif (isDraftable(base)) {\n\t\t\t// 1️⃣ 创建执行作用域 - 管理本次 produce 调用的生命周期\n\t\t\tconst scope = enterScope(this)\n\n\t\t\t// 2️⃣ 创建代理对象 - 实现写时复制的关键\n\t\t\tconst proxy = createProxy(base, undefined)\n\n\t\t\t// 3️⃣ 执行用户 recipe 函数，使用 try-finally 确保清理\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)  // 用户在代理上进行修改\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// 📝 清理工作：无论成功失败都要清理作用域\n\t\t\t\t// finally 比 catch + rethrow 更好地保留原始堆栈信息\n\t\t\t\tif (hasError) revokeScope(scope)  // 错误时撤销所有修改\n\t\t\t\telse leaveScope(scope)            // 正常完成时离开作用域\n\t\t\t}\n\n\t\t\t// 4️⃣ 处理补丁功能（如果启用）\n\t\t\tusePatchesInScope(scope, patchListener)\n\n\t\t\t// 5️⃣ 生成最终结果 - 进行最终化处理\n\t\t\treturn processResult(result, scope)\n\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\t// 🔄 处理原始值或不可代理对象\n\t\t\t// 直接调用 recipe，不创建代理\n\t\t\tresult = recipe(base)\n\n\t\t\t// 处理特殊返回值\n\t\t\tif (result === undefined) result = base      // undefined -> 保持原值\n\t\t\tif (result === NOTHING) result = undefined   // NOTHING -> 转为 undefined\n\n\t\t\t// 自动冻结（如果启用）\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\n\t\t\t// 生成替换补丁（整个对象被替换）\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []      // 正向补丁\n\t\t\t\tconst ip: Patch[] = []     // 逆向补丁\n\t\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip)\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else {\n\t\t\t// ❌ 无效的 base 参数\n\t\t\tdie(1, base)\n\t}\n\t}\n\n\t/**\n\t * 🎯 带补丁的 produce 方法\n\t *\n\t * 与 produce 相似，但总是返回元组 [nextState, patches, inversePatches]\n\t *\n\t * @param base 基础状态\n\t * @param recipe 修改函数\n\t * @returns [新状态, 正向补丁数组, 逆向补丁数组]\n\t */\n\tproduceWithPatches: IProduceWithPatches = (base: any, recipe?: any): any => {\n\t\t// 🔄 处理柯里化调用\n\t\tif (typeof base === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => base(draft, ...args))\n\t\t}\n\n\t\t// 📦 使用内部变量收集补丁信息\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p       // 正向补丁：如何从 base 到 result\n\t\t\tinversePatches = ip   // 逆向补丁：如何从 result 回到 base\n\t\t})\n\n\t\t// 📤 返回完整的补丁信息\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\t/**\n\t * 🔧 手动创建草稿对象\n\t *\n\t * 用于需要多步修改的复杂场景：\n\t * 1. 创建草稿但不立即完成\n\t * 2. 在多个函数间传递草稿\n\t * 3. 精确控制修改时机\n\t *\n\t * @param base 基础对象\n\t * @returns 草稿对象，可以直接修改\n\t */\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\t// 📋 验证：只有可代理对象才能创建草稿\n\t\tif (!isDraftable(base)) die(8)\n\n\t\t// 🔄 如果已经是草稿，先获取当前状态\n\t\tif (isDraft(base)) base = current(base)\n\n\t\t// 🎯 创建手动管理的草稿\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(base, undefined)\n\n\t\t// 🏷️ 标记为手动模式：不会自动完成\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\n\t\t// 📤 立即离开作用域，但保持草稿有效\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\t/**\n\t * 🎯 完成手动创建的草稿\n\t *\n\t * 将手动草稿转换为最终的不可变对象\n\t *\n\t * @param draft 通过 createDraft 创建的草稿\n\t * @param patchListener 可选的补丁监听器\n\t * @returns 最终的不可变对象\n\t */\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\t// 📋 获取草稿的内部状态\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\n\t\t// 🔍 验证：必须是手动创建的草稿\n\t\tif (!state || !state.isManual_) die(9)\n\n\t\t// 🎯 完成最终化处理\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)  // 处理补丁\n\t\treturn processResult(undefined, scope)   // undefined 表示使用草稿本身\n\t}\n\n\t/**\n\t * ⚙️ 设置自动冻结配置\n\t *\n\t * 自动冻结的作用：\n\t * - 防止意外修改不可变对象\n\t * - 提供更强的不可变保证\n\t * - 在开发时帮助发现错误使用\n\t *\n\t * 性能考虑：\n\t * - 冻结操作有性能开销\n\t * - 生产环境可以考虑关闭以提升性能\n\t *\n\t * @param value true=启用自动冻结，false=禁用\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * ⚙️ 设置严格浅拷贝模式\n\t *\n\t * 严格浅拷贝会保留：\n\t * - 属性描述符（writable、enumerable、configurable）\n\t * - getter 和 setter\n\t * - 原型链信息\n\t *\n\t * 适用场景：\n\t * - 处理复杂的类实例\n\t * - 需要保留完整对象语义\n\t * - 与现有代码库的兼容性要求\n\t *\n\t * @param value 严格模式配置\n\t */\n\tsetUseStrictShallowCopy(value: StrictMode) {\n\t\tthis.useStrictShallowCopy_ = value\n\t}\n\n\t/**\n\t * 🔄 应用补丁到对象\n\t *\n\t * 这个方法实现了补丁的\"重放\"功能：\n\t * 1. 优化：如果有完整替换补丁，直接使用替换值作为基础\n\t * 2. 对于草稿对象，直接应用补丁\n\t * 3. 对于普通对象，先创建草稿再应用补丁\n\t *\n\t * @param base 基础对象\n\t * @param patches 要应用的补丁数组\n\t * @returns 应用补丁后的新对象\n\t */\n\tapplyPatches<T extends Objectish>(base: T, patches: readonly Patch[]): T {\n\t\t// 🎯 优化：查找完整替换补丁\n\t\t// 如果存在路径为空且操作为 replace 的补丁，说明整个对象被替换\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value  // 使用替换值作为新的基础\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// 📝 跳过已处理的完整替换补丁\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\t// 🔧 获取补丁应用的具体实现（来自插件）\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\n\t\tif (isDraft(base)) {\n\t\t\t// 🎯 对草稿对象直接应用补丁\n\t\t\t// 注意：如果有替换补丁，补丁永远不会是草稿\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\n\t\t// 🔄 对普通对象：创建草稿后再应用补丁\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\n/**\n * 🏭 代理工厂函数 - 创建不同类型的代理对象\n *\n * 这个函数是代理创建的统一入口，根据对象类型选择合适的代理策略：\n * - Map -> MapSet 插件的 proxyMap_\n * - Set -> MapSet 插件的 proxySet_\n * - 普通对象/数组 -> createProxyProxy\n *\n * 设计优势：\n * 1. 统一的代理创建接口\n * 2. 插件化的类型处理\n * 3. 自动的作用域管理\n *\n * @param value 要代理的原始对象\n * @param parent 父级 ImmerState（用于嵌套对象）\n * @returns 创建的草稿代理对象\n */\nexport function createProxy<T extends Objectish>(\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// 🎯 根据对象类型选择代理策略\n\t// 前提：createProxy 应该被 isDraftable 保护，确保对象可以安全代理\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)    // Map 类型的特殊代理\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)    // Set 类型的特殊代理\n\t\t: createProxyProxy(value, parent)                 // 普通对象/数组的代理\n\n\t// 📋 作用域管理：将新创建的草稿注册到当前作用域\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)  // 用于最终化时的清理和处理\n\n\treturn draft\n}\n","/**\n * current.ts - 草稿状态快照功能\n *\n * 这个模块提供了获取草稿对象当前状态快照的功能。由于草稿对象内部使用Proxy实现，\n * 在调试或检查状态时很难直接观察到实际的数据结构。current函数解决了这个问题，\n * 它能够创建一个纯净的、可序列化的状态快照，去除所有的Proxy包装。\n *\n * 主要特性：\n * - 移除Proxy包装，返回纯净的对象\n * - 递归处理嵌套的草稿对象\n * - 性能优化：未修改的草稿直接返回base对象\n * - 调试友好：输出可以安全地泄露到producer外部\n */\n\nimport {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tisFrozen\n} from \"../internal\"\n\n/**\n * 获取草稿对象的当前状态快照\n *\n * 这是一个重要的调试工具，它会创建草稿对象的深度快照，移除所有Proxy包装，\n * 返回一个纯净的、可以安全检查和序列化的对象。这对于调试非常有用，\n * 因为你可以console.log输出而不会看到复杂的Proxy结构。\n *\n * 使用场景：\n * - 调试时检查草稿的当前状态\n * - 需要将草稿状态传递给外部代码\n * - 测试中验证中间状态\n *\n * @param value - 要获取快照的草稿对象\n * @returns 草稿对象的纯净状态快照（移除了所有Proxy包装）\n *\n * @throws 如果传入的值不是草稿对象，会抛出错误\n *\n * @example\n * const draft = produce(baseState, draft => {\n *   draft.user.name = \"Alice\";\n *   console.log(current(draft)); // 输出纯净的对象，没有Proxy\n * });\n */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\t// 安全检查：确保传入的是草稿对象\n\tif (!isDraft(value)) die(10, value)\n\treturn currentImpl(value)\n}\n\n/**\n * current函数的内部实现\n *\n * 这个函数负责递归地处理草稿对象，创建深度快照。它会：\n * 1. 处理不同类型的值（原始值、冻结对象、草稿对象）\n * 2. 优化性能：未修改的草稿直接返回base对象\n * 3. 递归处理嵌套的草稿对象\n * 4. 临时设置finalized_标志来避免在拷贝过程中创建新的草稿\n *\n * @param value - 要处理的值（可能是草稿对象或普通值）\n * @returns 该值的纯净快照\n */\nfunction currentImpl(value: any): any {\n\t// 快速路径：如果不是可草稿化的对象或已经冻结，直接返回\n\t// 这包括：原始类型、函数、已冻结的对象等\n\tif (!isDraftable(value) || isFrozen(value)) return value\n\n\t// 获取草稿状态信息\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\n\tif (state) {\n\t\t// 这是一个草稿对象\n\n\t\t// 性能优化：如果草稿未被修改，直接返回base对象\n\t\t// 这避免了不必要的拷贝操作\n\t\tif (!state.modified_) return state.base_\n\n\t\t// 临时标记为已完成，防止在拷贝过程中创建新的草稿对象\n\t\t// 这是一个重要的优化，避免了递归过程中的无限循环\n\t\tstate.finalized_ = true\n\n\t\t// 创建浅拷贝，使用当前作用域的拷贝策略\n\t\tcopy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_)\n\t} else {\n\t\t// 这不是草稿对象，但可能包含草稿属性，所以也需要处理\n\t\t// 使用严格的浅拷贝策略\n\t\tcopy = shallowCopy(value, true)\n\t}\n\n\t// 递归处理：遍历所有属性，递归调用currentImpl\n\t// 这确保了嵌套的草稿对象也会被正确处理\n\teach(copy, (key, childValue) => {\n\t\t// 递归处理每个属性值，如果是草稿则获取其快照\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\n\t// 恢复finalized_状态，确保草稿对象的状态不被永久改变\n\tif (state) {\n\t\tstate.finalized_ = false\n\t}\n\n\treturn copy\n}\n","/**\n * patches.ts - 补丁系统插件\n *\n * 这个插件实现了immer的补丁系统，提供状态变更的跟踪、记录和应用功能。\n * 补丁系统遵循JSON Patch规范（RFC 6902），支持三种操作：add、remove、replace。\n *\n * 核心功能：\n * - 生成正向补丁：描述如何从旧状态到新状态\n * - 生成逆向补丁：描述如何从新状态回到旧状态\n * - 应用补丁：将补丁应用到指定对象上\n * - 深度克隆：确保补丁中的值不会意外修改\n *\n * 应用场景：\n * - 状态同步：客户端间的状态同步\n * - 撤销重做：基于补丁的历史管理\n * - 调试工具：可视化状态变更\n * - 持久化：只保存变更而不是完整状态\n * - 协同编辑：冲突检测和解决\n *\n * 设计挑战：\n * - 不同数据结构：Object、Array、Map、Set的不同处理\n * - 路径计算：准确定位嵌套属性的变更\n * - 值克隆：避免补丁值的意外修改\n * - 安全性：防止原型污染攻击\n */\n\nimport {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tProxyArrayState,\n\tMapState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tgetPrototypeOf,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tArchType,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING,\n\terrors\n} from \"../internal\"\n\n/**\n * enablePatches - 启用补丁系统\n *\n * 这是补丁插件的入口函数，定义了所有补丁相关的功能\n * 并将它们注册到插件系统中。\n */\nexport function enablePatches() {\n\t/**\n\t * 错误偏移量\n\t *\n\t * 补丁系统有自己的错误代码，从16开始编号\n\t * 以避免与核心错误代码冲突\n\t */\n\tconst errorOffset = 16\n\n\t// 添加补丁系统特有的错误信息\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\terrors.push(\n\t\t\t'Sets cannot have \"replace\" patches.',     // 错误16：Set不能有replace补丁\n\t\t\tfunction(op: string) {                      // 错误17：不支持的补丁操作\n\t\t\t\treturn \"Unsupported patch operation: \" + op\n\t\t\t},\n\t\t\tfunction(path: string) {                    // 错误18：补丁路径无法解析\n\t\t\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t\t\t},\n\t\t\t// 错误19：禁止修改保留属性\n\t\t\t\"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n\t\t)\n\t}\n\n\t// 补丁操作类型常量\n\tconst REPLACE = \"replace\"  // 替换操作\n\tconst ADD = \"add\"         // 添加操作\n\tconst REMOVE = \"remove\"   // 删除操作\n\n\t/**\n\t * generatePatches_ - 生成标准补丁\n\t *\n\t * 根据草稿状态的类型选择相应的补丁生成策略。\n\t * 不同的数据结构需要不同的处理逻辑。\n\t *\n\t * @param state - 草稿状态对象\n\t * @param basePath - 当前对象的路径\n\t * @param patches - 正向补丁数组\n\t * @param inversePatches - 逆向补丁数组\n\t */\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\t// 根据数据结构类型分发处理\n\t\tswitch (state.type_) {\n\t\t\tcase ArchType.Object:\n\t\t\tcase ArchType.Map:\n\t\t\t\t// 对象和Map使用相同的处理逻辑（基于assigned_）\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t\tcase ArchType.Array:\n\t\t\t\t// 数组有特殊的处理逻辑\n\t\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\t\tcase ArchType.Set:\n\t\t\t\t// Set需要特殊处理\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t}\n\t}\n\n\t/**\n\t * generateArrayPatches - 生成数组补丁\n\t *\n\t * 数组补丁生成有特殊的复杂性：\n\t * - 索引变化：元素的添加和删除会影响后续元素的索引\n\t * - 长度变化：数组长度的变化需要特殊处理\n\t * - 效率优化：通过base/copy交换简化处理逻辑\n\t *\n\t * @param state - 数组草稿状态\n\t * @param basePath - 当前路径\n\t * @param patches - 正向补丁数组\n\t * @param inversePatches - 逆向补丁数组\n\t */\n\tfunction generateArrayPatches(\n\t\tstate: ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// 性能优化：确保base永远不会比copy长\n\t\t// 通过交换base和copy简化后续的处理逻辑\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t// 同时交换补丁数组，保持逻辑一致性\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\t// 处理被替换的索引\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tif (assigned_[i] && copy_[i] !== base_[i]) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// 需要克隆值，因为由于上面的base/copy交换，\n\t\t\t\t\t// 这实际上可能是原始值\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(base_[i])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// 处理添加的索引（新增元素）\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// 需要克隆值，原因同上\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\n\t\t// 处理删除的索引（移除元素）\n\t\t// 注意：删除补丁需要从后往前生成，以保证索引的正确性\n\t\tfor (let i = copy_.length - 1; base_.length <= i; --i) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tinversePatches.push({\n\t\t\t\top: REMOVE,\n\t\t\t\tpath\n\t\t\t})\n\t\t}\n\t}\n\n\t/**\n\t * generatePatchesFromAssigned - 基于分配记录生成补丁\n\t *\n\t * 这个函数同时用于处理Map对象和普通对象，因为它们都使用\n\t * assigned_字段来跟踪属性的修改状态。\n\t *\n\t * @param state - Map或Object的草稿状态\n\t * @param basePath - 当前路径\n\t * @param patches - 正向补丁数组\n\t * @param inversePatches - 逆向补丁数组\n\t */\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_} = state\n\n\t\t// 遍历所有分配记录\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key)\n\t\t\tconst value = get(copy_!, key)\n\n\t\t\t// 根据分配状态确定操作类型\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\n\t\t\t// 性能优化：如果值相同且是替换操作，跳过\n\t\t\tif (origValue === value && op === REPLACE) return\n\n\t\t\tconst path = basePath.concat(key as any)\n\n\t\t\t// 生成正向补丁\n\t\t\tpatches.push(op === REMOVE ? {op, path} : {op, path, value})\n\n\t\t\t// 生成逆向补丁\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}  // ADD的逆向是REMOVE\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)} // REMOVE的逆向是ADD\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)} // REPLACE的逆向是REPLACE\n\t\t\t)\n\t\t})\n\t}\n\n\t/**\n\t * generateSetPatches - 生成Set补丁\n\t *\n\t * Set的补丁生成最为复杂，因为：\n\t * - Set没有键的概念，只能基于插入顺序生成路径\n\t * - 需要检测哪些值被添加、哪些值被删除\n\t * - 插入顺序必须在补丁中保持\n\t *\n\t * @param state - Set草稿状态\n\t * @param basePath - 当前路径\n\t * @param patches - 正向补丁数组\n\t * @param inversePatches - 逆向补丁数组\n\t */\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\t// 检查删除的值\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue // Set的删除需要指定值\n\t\t\t\t})\n\t\t\t\t// 注意：使用unshift保持逆向补丁的正确顺序\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\n\t\ti = 0\n\t\t// 检查添加的值\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\t// 注意：使用unshift保持逆向补丁的正确顺序\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\t/**\n\t * generateReplacementPatches_ - 生成替换补丁\n\t *\n\t * 当producer函数返回全新对象时（替换模式），生成描述\n\t * 整个对象被替换的补丁。这比详细的属性级补丁更简洁。\n\t *\n\t * @param baseValue - 原始值\n\t * @param replacement - 替换值\n\t * @param patches - 正向补丁数组\n\t * @param inversePatches - 逆向补丁数组\n\t */\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\t// 正向补丁：将根路径替换为新值\n\t\tpatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\t// 逆向补丁：将根路径替换为原始值\n\t\tinversePatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\t/**\n\t * applyPatches_ - 应用补丁\n\t *\n\t * 将补丁数组应用到目标对象上。这个函数需要处理各种复杂情况：\n\t * - 路径解析：正确导航到目标位置\n\t * - 类型检查：确保操作与目标类型兼容\n\t * - 安全检查：防止原型污染攻击\n\t * - 值克隆：避免补丁值的意外修改\n\t *\n\t * @param draft - 目标对象（会被修改）\n\t * @param patches - 要应用的补丁数组\n\t * @returns 修改后的对象\n\t */\n\tfunction applyPatches_<T>(draft: T, patches: readonly Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\t// 导航到补丁的目标位置（除了最后一级）\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tlet p = path[i]\n\n\t\t\t\t// 类型标准化：确保路径组件是字符串或数字\n\t\t\t\tif (typeof p !== \"string\" && typeof p !== \"number\") {\n\t\t\t\t\tp = \"\" + p\n\t\t\t\t}\n\n\t\t\t\t// 安全检查：防止原型污染攻击（参见#738）\n\t\t\t\tif (\n\t\t\t\t\t(parentType === ArchType.Object || parentType === ArchType.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === \"constructor\")\n\t\t\t\t)\n\t\t\t\t\tdie(errorOffset + 3)\n\t\t\t\tif (typeof base === \"function\" && p === \"prototype\")\n\t\t\t\t\tdie(errorOffset + 3)\n\n\t\t\t\t// 继续导航\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (typeof base !== \"object\") die(errorOffset + 2, path.join(\"/\"))\n\t\t\t}\n\n\t\t\t// 获取目标类型和操作参数\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // 克隆补丁值以确保原始补丁不被修改，参见#411\n\t\t\tconst key = path[path.length - 1]\n\n\t\t\t// 根据操作类型执行相应的操作\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\t// Set不能有replace操作\n\t\t\t\t\t\t\tdie(errorOffset)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// 普通对象和数组：直接赋值\n\t\t\t\t\t\t\t// 如果value是对象，则通过引用赋值\n\t\t\t\t\t\t\t// 在下面的add或remove操作中，补丁内的value字段也会被修改\n\t\t\t\t\t\t\t// 所以我们使用克隆补丁的值\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Array:\n\t\t\t\t\t\t\t// 数组添加的特殊处理\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)  // \"-\"表示添加到末尾\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value) // 在指定位置插入\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// 普通对象：设置属性\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Array:\n\t\t\t\t\t\t\t// 数组删除：移除指定索引的元素\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\t// Set删除：删除指定的值\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// 普通对象：删除属性\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\t// 不支持的操作\n\t\t\t\t\tdie(errorOffset + 1, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t/**\n\t * deepClonePatchValue - 深度克隆补丁值\n\t *\n\t * 这是一个性能关键的函数，用于克隆补丁中的值以防止意外修改。\n\t * 可以考虑智能检测何时需要克隆，例如当新对象来自外部被分配和修改时自动草稿化。\n\t *\n\t * @param obj - 要克隆的对象\n\t * @returns 深度克隆的对象\n\t */\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\t// 快速路径：不可草稿化的值直接返回\n\t\tif (!isDraftable(obj)) return obj\n\n\t\t// 递归克隆不同类型的对象\n\t\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\n\t\t// 普通对象的克隆\n\t\tconst cloned = Object.create(getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\n\t\t// 保持immerable标记\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\t/**\n\t * clonePatchValueIfNeeded - 按需克隆补丁值\n\t *\n\t * 只有当值是草稿时才进行深度克隆，普通值直接返回。\n\t *\n\t * @param obj - 可能需要克隆的值\n\t * @returns 克隆的值或原值\n\t */\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\t// 注册补丁插件\n\tloadPlugin(\"Patches\", {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_\n\t})\n}\n","/**\n * mapset.ts - Map和Set数据结构支持插件\n *\n * 这个插件为ES6的Map和Set提供草稿化支持。由于Map和Set的特殊性质，\n * 它们不能使用标准的Proxy属性劫持，需要专门的实现策略。\n *\n * 核心挑战：\n * - 方法劫持：Map/Set的操作通过方法而不是属性\n * - 迭代顺序：必须保持严格的插入顺序语义\n * - 值唯一性：Set的值唯一性约束需要特殊处理\n * - 嵌套草稿：Map/Set中的值可能也需要草稿化\n *\n * 设计策略：\n * - 类继承：通过继承Map/Set重写关键方法\n * - 延迟拷贝：copy_在首次修改时创建\n * - 状态跟踪：assigned_记录键的修改状态\n * - 双重映射：Set使用drafts_映射原始值到草稿值\n *\n * 性能考虑：\n * - 懒初始化：避免不必要的Map/Set创建\n * - 引用复用：未修改的值保持原始引用\n * - 迭代优化：特殊处理迭代器和forEach\n */\n\n// 仅导入类型！\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tdie,\n\tArchType,\n\teach\n} from \"../internal\"\n\n/**\n * enableMapSet - 启用Map和Set支持\n *\n * 这是插件的入口函数，定义了DraftMap和DraftSet类，\n * 并将它们注册到插件系统中。只有调用此函数后，\n * immer才能处理Map和Set对象。\n *\n * 插件加载：\n * - 延迟加载：只在调用时才定义类和加载插件\n * - 一次性：重复调用不会产生副作用\n * - 类型安全：完整的TypeScript类型支持\n */\nexport function enableMapSet() {\n\t/**\n\t * DraftMap - Map的草稿实现类\n\t *\n\t * 通过继承原生Map类并重写关键方法来实现草稿化。\n\t * 每个方法都会检查和更新内部状态，确保正确的\n\t * 写时复制行为。\n\t *\n\t * 核心特性：\n\t * - 透明接口：与原生Map完全兼容的API\n\t * - 延迟拷贝：只在实际修改时创建副本\n\t * - 状态跟踪：精确记录哪些键被修改\n\t * - 嵌套支持：自动处理值的草稿化\n\t */\n\tclass DraftMap extends Map {\n\t\t/**\n\t\t * 草稿状态标识\n\t\t * 使用Symbol键存储Map的草稿状态信息\n\t\t */\n\t\t[DRAFT_STATE]: MapState\n\n\t\t/**\n\t\t * 构造函数 - 初始化Map草稿\n\t\t *\n\t\t * @param target - 要草稿化的原始Map\n\t\t * @param parent - 父级草稿状态（用于嵌套）\n\t\t */\n\t\tconstructor(target: AnyMap, parent?: ImmerState) {\n\t\t\tsuper() // 调用原生Map构造函数\n\n\t\t\t// 初始化草稿状态\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ArchType.Map,                          // 类型标识\n\t\t\t\tparent_: parent,                              // 父级状态\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!, // 作用域\n\t\t\t\tmodified_: false,                             // 修改标记\n\t\t\t\tfinalized_: false,                            // 最终化标记\n\t\t\t\tcopy_: undefined,                             // 副本（懒创建）\n\t\t\t\tassigned_: undefined,                         // 分配跟踪（懒创建）\n\t\t\t\tbase_: target,                                // 原始Map\n\t\t\t\tdraft_: this as any,                          // 草稿引用\n\t\t\t\tisManual_: false,                             // 自动管理\n\t\t\t\trevoked_: false                               // 撤销标记\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * size属性 - 获取Map大小\n\t\t *\n\t\t * 返回当前有效状态的大小。如果已修改，返回copy的大小；\n\t\t * 否则返回base的大小。\n\t\t */\n\t\tget size(): number {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t}\n\n\t\t/**\n\t\t * has方法 - 检查键是否存在\n\t\t *\n\t\t * @param key - 要检查的键\n\t\t * @returns 键是否存在\n\t\t */\n\t\thas(key: any): boolean {\n\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t}\n\n\t\t/**\n\t\t * set方法 - 设置键值对\n\t\t *\n\t\t * 这是Map修改的核心方法，实现了写时复制逻辑。\n\t\t * 只有在值真正发生变化时才会创建副本和标记修改。\n\t\t *\n\t\t * @param key - 要设置的键\n\t\t * @param value - 要设置的值\n\t\t * @returns this（支持链式调用）\n\t\t */\n\t\tset(key: any, value: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t// 安全检查：确保代理未被撤销\n\t\t\tassertUnrevoked(state)\n\n\t\t\t// 检查是否为真实的变更\n\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\t// 准备副本和分配跟踪\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\t// 标记为已修改\n\t\t\t\tmarkChanged(state)\n\t\t\t\t// 记录键的分配状态\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\t// 设置新值\n\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\t// 重复记录（确保状态一致性）\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\t/**\n\t\t * delete方法 - 删除键值对\n\t\t *\n\t\t * @param key - 要删除的键\n\t\t * @returns 是否成功删除\n\t\t */\n\t\tdelete(key: any): boolean {\n\t\t\t// 快速检查：键不存在直接返回false\n\t\t\tif (!this.has(key)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\n\t\t\t// 准备修改\n\t\t\tprepareMapCopy(state)\n\t\t\tmarkChanged(state)\n\n\t\t\t// 更新分配跟踪\n\t\t\tif (state.base_.has(key)) {\n\t\t\t\t// 原本存在的键标记为删除\n\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t} else {\n\t\t\t\t// 新添加后又删除的键直接移除跟踪\n\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t}\n\n\t\t\t// 从副本中删除\n\t\t\tstate.copy_!.delete(key)\n\t\t\treturn true\n\t\t}\n\n\t\t/**\n\t\t * clear方法 - 清空Map\n\t\t *\n\t\t * 删除所有键值对，等同于删除每个键。\n\t\t */\n\t\tclear() {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\n\t\t\t// 只有在非空时才需要处理\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\n\t\t\t\t// 重置分配跟踪\n\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\t// 将所有原始键标记为删除\n\t\t\t\teach(state.base_, key => {\n\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t})\n\t\t\t\t// 清空副本\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * forEach方法 - 遍历Map\n\t\t *\n\t\t * 注意：回调函数接收的值可能是草稿化的，\n\t\t * 这确保了在遍历过程中访问嵌套对象时的一致性。\n\t\t *\n\t\t * @param cb - 回调函数\n\t\t * @param thisArg - this绑定值\n\t\t */\n\t\tforEach(cb: (value: any, key: any, self: any) => void, thisArg?: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\t// 遍历最新状态，但通过get方法获取可能的草稿值\n\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t})\n\t\t}\n\n\t\t/**\n\t\t * get方法 - 获取键对应的值\n\t\t *\n\t\t * 这个方法可能返回草稿化的值。如果值是可草稿化的对象\n\t\t * 且首次访问，会自动创建草稿并缓存。\n\t\t *\n\t\t * @param key - 要获取的键\n\t\t * @returns 对应的值（可能是草稿）\n\t\t */\n\t\tget(key: any): any {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\n\t\t\tconst value = latest(state).get(key)\n\n\t\t\t// 快速路径：已最终化或不可草稿化的值\n\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\treturn value\n\t\t\t}\n\n\t\t\t// 检查是否为新访问的值\n\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\treturn value // 已经是草稿或被重新赋值\n\t\t\t}\n\n\t\t\t// 创建嵌套草稿（只创建一次，参见上面的条件）\n\t\t\tconst draft = createProxy(value, state)\n\t\t\tprepareMapCopy(state)\n\t\t\tstate.copy_!.set(key, draft)\n\t\t\treturn draft\n\t\t}\n\n\t\t/**\n\t\t * keys方法 - 获取键的迭代器\n\t\t *\n\t\t * @returns 键的迭代器\n\t\t */\n\t\tkeys(): IterableIterator<any> {\n\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t}\n\n\t\t/**\n\t\t * values方法 - 获取值的迭代器\n\t\t *\n\t\t * 返回的迭代器会通过get方法获取值，确保返回的是\n\t\t * 正确的草稿化值。\n\t\t *\n\t\t * @returns 值的迭代器\n\t\t */\n\t\tvalues(): IterableIterator<any> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[Symbol.iterator]: () => this.values(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\t// 通过get方法获取可能的草稿值\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\t/**\n\t\t * entries方法 - 获取键值对的迭代器\n\t\t *\n\t\t * @returns 键值对的迭代器\n\t\t */\n\t\tentries(): IterableIterator<[any, any]> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[Symbol.iterator]: () => this.entries(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\t// 通过get方法获取可能的草稿值\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\t/**\n\t\t * Symbol.iterator方法 - 默认迭代器\n\t\t *\n\t\t * Map的默认迭代器是entries迭代器\n\t\t */\n\t\t[Symbol.iterator]() {\n\t\t\treturn this.entries()\n\t\t}\n\t}\n\n\t/**\n\t * proxyMap_ - 创建Map代理\n\t *\n\t * @param target - 要代理的原始Map\n\t * @param parent - 父级草稿状态\n\t * @returns Map的草稿代理\n\t */\n\tfunction proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftMap(target, parent)\n\t}\n\n\t/**\n\t * prepareMapCopy - 准备Map的副本\n\t *\n\t * 延迟创建Map的副本和分配跟踪。这是写时复制的核心实现。\n\t *\n\t * @param state - Map的草稿状态\n\t */\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\t// 创建分配跟踪表\n\t\t\tstate.assigned_ = new Map()\n\t\t\t// 创建原始Map的副本\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\t/**\n\t * DraftSet - Set的草稿实现类\n\t *\n\t * Set的草稿化比Map更复杂，因为：\n\t * 1. Set中的值可能需要草稿化\n\t * 2. 需要正确匹配原始值和草稿值\n\t * 3. 必须保持值的唯一性约束\n\t * 4. 插入顺序必须保持\n\t */\n\tclass DraftSet extends Set {\n\t\t[DRAFT_STATE]: SetState\n\n\t\tconstructor(target: AnySet, parent?: ImmerState) {\n\t\t\tsuper()\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ArchType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,                             // Set副本\n\t\t\t\tbase_: target,                                // 原始Set\n\t\t\t\tdraft_: this,                                 // 草稿引用\n\t\t\t\tdrafts_: new Map(),                           // 原始值→草稿值映射\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * size属性 - 获取Set大小\n\t\t */\n\t\tget size(): number {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t}\n\n\t\t/**\n\t\t * has方法 - 检查值是否存在\n\t\t *\n\t\t * 需要特殊处理：既要检查原始值，也要检查对应的草稿值\n\t\t *\n\t\t * @param value - 要检查的值\n\t\t * @returns 值是否存在\n\t\t */\n\t\thas(value: any): boolean {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\n\t\t\t// 复杂的检查逻辑：能够识别值和其草稿版本\n\t\t\tif (!state.copy_) {\n\t\t\t\treturn state.base_.has(value)\n\t\t\t}\n\t\t\tif (state.copy_.has(value)) return true\n\t\t\t// 检查是否存在对应的草稿值\n\t\t\tif (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n\t\t\t\treturn true\n\t\t\treturn false\n\t\t}\n\n\t\t/**\n\t\t * add方法 - 添加值到Set\n\t\t *\n\t\t * @param value - 要添加的值\n\t\t * @returns this（支持链式调用）\n\t\t */\n\t\tadd(value: any): any {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\n\t\t\tif (!this.has(value)) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.add(value)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\t/**\n\t\t * delete方法 - 删除值\n\t\t *\n\t\t * @param value - 要删除的值\n\t\t * @returns 是否成功删除\n\t\t */\n\t\tdelete(value: any): any {\n\t\t\tif (!this.has(value)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\tmarkChanged(state)\n\n\t\t\t// 尝试删除原始值或对应的草稿值\n\t\t\treturn (\n\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t)\n\t\t}\n\n\t\t/**\n\t\t * clear方法 - 清空Set\n\t\t */\n\t\tclear() {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * values方法 - 获取值的迭代器\n\t\t *\n\t\t * 注意：为了保持插入顺序和正确处理草稿值，\n\t\t * 我们需要准备副本并返回副本的迭代器\n\t\t */\n\t\tvalues(): IterableIterator<any> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.values()\n\t\t}\n\n\t\t/**\n\t\t * entries方法 - 获取值对的迭代器\n\t\t *\n\t\t * Set的entries返回[value, value]格式\n\t\t */\n\t\tentries(): IterableIterator<[any, any]> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.entries()\n\t\t}\n\n\t\t/**\n\t\t * keys方法 - 获取键的迭代器\n\t\t *\n\t\t * 对于Set，keys等同于values\n\t\t */\n\t\tkeys(): IterableIterator<any> {\n\t\t\treturn this.values()\n\t\t}\n\n\t\t/**\n\t\t * Symbol.iterator方法 - 默认迭代器\n\t\t */\n\t\t[Symbol.iterator]() {\n\t\t\treturn this.values()\n\t\t}\n\n\t\t/**\n\t\t * forEach方法 - 遍历Set\n\t\t *\n\t\t * @param cb - 回调函数\n\t\t * @param thisArg - this绑定值\n\t\t */\n\t\tforEach(cb: any, thisArg?: any) {\n\t\t\tconst iterator = this.values()\n\t\t\tlet result = iterator.next()\n\t\t\twhile (!result.done) {\n\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\tresult = iterator.next()\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * proxySet_ - 创建Set代理\n\t *\n\t * @param target - 要代理的原始Set\n\t * @param parent - 父级草稿状态\n\t * @returns Set的草稿代理\n\t */\n\tfunction proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftSet(target, parent)\n\t}\n\n\t/**\n\t * prepareSetCopy - 准备Set的副本\n\t *\n\t * Set的副本准备是最复杂的，因为需要处理值的草稿化\n\t * 并建立原始值到草稿值的映射关系。\n\t *\n\t * @param state - Set的草稿状态\n\t */\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// 创建新的Set副本\n\t\t\tstate.copy_ = new Set()\n\n\t\t\t// 遍历原始Set，为每个值创建草稿（如果需要）\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\t// 可草稿化的值：创建草稿并建立映射\n\t\t\t\t\tconst draft = createProxy(value, state)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\t// 不可草稿化的值：直接添加\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\t/**\n\t * assertUnrevoked - 检查状态是否已撤销\n\t *\n\t * 确保代理对象仍然可用，如果已撤销则抛出错误\n\t *\n\t * @param state - 要检查的状态对象\n\t */\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\t// 加载插件到系统中\n\tloadPlugin(\"MapSet\", {proxyMap_, proxySet_})\n}\n","/**\n * immer.ts - Immer库主入口文件\n *\n * 这是immer库的公共API入口，负责：\n * 1. 统一导出所有公共接口和类型\n * 2. 创建默认的Immer实例并绑定核心方法\n * 3. 提供便利的类型转换函数\n * 4. 管理插件系统的启用\n *\n * 设计理念：\n * - 简单易用：提供直接可用的函数而不需要实例化\n * - 类型安全：完整的TypeScript类型支持\n * - 按需加载：插件系统支持功能的按需启用\n * - 向后兼容：稳定的公共API设计\n *\n * 主要特性：\n * - produce: 核心的不可变更新函数\n * - createDraft/finishDraft: 手动草稿管理\n * - 补丁系统：跟踪和应用状态变更\n * - 类型转换：Draft和Immutable类型的安全转换\n */\n\nimport {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\n/**\n * 公共API和类型导出\n *\n * 这些是immer对外提供的完整接口，包括：\n * - 类型定义：Draft, Immutable, Patch等核心类型\n * - 工具函数：original, current, isDraft等实用函数\n * - 常量：nothing, immerable等特殊标识符\n * - 配置：freeze, StrictMode等行为控制\n */\nexport {\n\tDraft,           // 草稿类型，用户在producer中操作的类型\n\tWritableDraft,   // 可写草稿类型，更明确的语义表达\n\tImmutable,       // 不可变类型，确保类型级别的不可变性\n\tPatch,           // 补丁对象类型，描述状态变更\n\tPatchListener,   // 补丁监听器类型，处理补丁事件\n\tProducer,        // 生产者函数类型，用户编写的状态变更逻辑\n\toriginal,        // 获取草稿对应的原始对象\n\tcurrent,         // 获取草稿的当前状态快照\n\tisDraft,         // 判断对象是否为草稿\n\tisDraftable,     // 判断对象是否可以被草稿化\n\tNOTHING as nothing,      // 删除标记，在producer中返回表示删除\n\tDRAFTABLE as immerable,  // 可草稿化标记，类实例需要添加此属性\n\tfreeze,          // 冻结函数，确保对象不可变\n\tObjectish,       // 可处理的对象类型联合\n\tStrictMode       // 严格模式配置类型\n} from \"./internal\"\n\n/**\n * 默认Immer实例\n *\n * 创建一个全局共享的Immer实例，这样用户可以直接使用函数\n * 而不需要手动创建实例。这个实例使用默认配置：\n * - autoFreeze: true (自动冻结结果)\n * - useStrictShallowCopy: false (非严格浅拷贝)\n */\nconst immer = new Immer()\n\n/**\n * produce - 核心的不可变状态更新函数\n *\n * 这是immer最重要的API，用于安全地\"修改\"不可变状态。\n * 它接受一个基础状态和一个\"配方函数\"，配方函数可以自由\n * 修改传入的草稿对象，所有修改都只会应用到基础状态的副本上。\n *\n * 支持多种调用模式：\n *\n * 1. 标准模式：\n * const nextState = produce(baseState, draft => {\n *   draft.user.name = \"Alice\"\n * })\n *\n * 2. 柯里化模式：\n * const updateUser = produce(draft => {\n *   draft.user.name = \"Alice\"\n * })\n * const nextState = updateUser(baseState)\n *\n * 3. 带补丁监听：\n * const nextState = produce(baseState, draft => {\n *   draft.user.name = \"Alice\"\n * }, patches => {\n *   console.log(\"应用的补丁：\", patches)\n * })\n *\n * 重要特性：\n * - 结构共享：未修改的部分会被重用，节省内存\n * - 类型安全：完整的TypeScript类型推导\n * - 性能优化：只有被修改的部分会被复制\n * - 错误安全：自动处理各种边界情况\n *\n * 注意：这个函数被绑定到默认的Immer实例\n *\n * @param base - 初始状态对象\n * @param producer - 接受草稿作为第一参数的函数，可以自由修改\n * @param patchListener - 可选的补丁监听函数，接收生成的补丁\n * @returns 新状态，如果没有修改则返回原始状态\n */\nexport const produce: IProduce = immer.produce\n\n/**\n * produceWithPatches - 返回状态和补丁的produce版本\n *\n * 与produce类似，但总是返回一个三元组：\n * [nextState, patches, inversePatches]\n *\n * 这对于需要补丁信息的场景非常有用：\n * - 状态同步：将补丁发送到其他客户端\n * - 撤销/重做：使用inversePatches实现状态回滚\n * - 调试：检查具体的状态变更\n * - 持久化：只保存变更而不是完整状态\n *\n * @example\n * const [nextState, patches, inversePatches] = produceWithPatches(\n *   baseState,\n *   draft => {\n *     draft.user.name = \"Alice\"\n *   }\n * )\n *\n * // patches 描述了如何从baseState得到nextState\n * // inversePatches 描述了如何从nextState回到baseState\n *\n * 注意：需要先启用Patches插件才能使用\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * setAutoFreeze - 配置自动冻结行为\n *\n * 控制immer是否自动冻结生成的结果对象。冻结确保了对象的\n * 不可变性，防止意外修改，但在某些场景下可能影响性能。\n *\n * 默认行为：\n * - 开发环境：true (帮助捕获错误)\n * - 生产环境：true (但可以关闭以提高性能)\n *\n * 使用场景：\n * - 性能敏感：关闭自动冻结以提高性能\n * - 调试：开启以捕获意外的状态修改\n * - 兼容性：某些库可能需要修改对象\n *\n * @param autoFreeze - true表示自动冻结，false表示不冻结\n *\n * @example\n * setAutoFreeze(false) // 关闭自动冻结以提高性能\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * setUseStrictShallowCopy - 配置严格浅拷贝模式\n *\n * 控制immer在创建对象副本时是否严格复制所有属性描述符。\n * 默认情况下，immer不会复制getter、setter和不可枚举属性\n * 等描述符信息，这样可以提高性能。\n *\n * 严格模式的影响：\n * - 复制所有属性描述符（getter、setter、configurable等）\n * - 保持属性的完整语义\n * - 性能开销更大\n * - 更好的语义正确性\n *\n * 使用场景：\n * - 需要保持完整属性语义的场景\n * - 对象包含重要的getter/setter逻辑\n * - 兼容依赖属性描述符的代码\n *\n * @param strict - true表示使用严格浅拷贝\n *\n * @example\n * setUseStrictShallowCopy(true) // 启用严格拷贝\n */\nexport const setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer)\n\n/**\n * applyPatches - 应用补丁到对象\n *\n * 将一组补丁应用到目标对象上，生成新的状态。这个函数\n * 也是一个producer，意味着它使用写时复制机制。\n *\n * 主要用途：\n * - 状态同步：应用从其他地方接收的补丁\n * - 重放：重现一系列状态变更\n * - 撤销/重做：应用或撤销补丁\n * - 增量更新：只传输变更而不是完整状态\n *\n * @param base - 要应用补丁的基础对象\n * @param patches - 要应用的补丁数组\n * @returns 应用补丁后的新状态\n *\n * @example\n * const patches = [\n *   { op: \"replace\", path: [\"user\", \"name\"], value: \"Alice\" }\n * ]\n * const newState = applyPatches(baseState, patches)\n *\n * 注意：需要先启用Patches插件才能使用\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * createDraft - 手动创建草稿对象\n *\n * 创建一个可以手动管理的草稿对象。与produce不同，\n * 这个草稿的生命周期由用户控制，需要手动调用\n * finishDraft来完成最终化。\n *\n * 适用场景：\n * - 需要在多个函数间传递草稿\n * - 异步操作中修改状态\n * - 条件性的状态修改\n * - 更细粒度的控制需求\n *\n * 注意事项：\n * - 必须调用finishDraft来完成修改\n * - 草稿对象不能在finishDraft后继续使用\n * - 草稿会占用资源直到被完成\n *\n * @param base - 要创建草稿的基础对象\n * @returns 可修改的草稿对象\n *\n * @example\n * const draft = createDraft(baseState)\n * draft.user.name = \"Alice\"\n * const newState = finishDraft(draft)\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * finishDraft - 完成手动草稿的修改\n *\n * 完成通过createDraft创建的草稿的修改过程，返回\n * 最终的不可变状态。如果没有修改，会返回原始的\n * base对象（结构共享）。\n *\n * 完成过程包括：\n * - 最终化所有嵌套的草稿对象\n * - 应用写时复制优化\n * - 根据配置冻结结果\n * - 生成补丁（如果提供了监听器）\n * - 清理草稿资源\n *\n * @param draft - 由createDraft创建的草稿对象\n * @param patchListener - 可选的补丁监听函数\n * @returns 最终的不可变状态\n *\n * @example\n * const draft = createDraft(baseState)\n * draft.user.name = \"Alice\"\n * const newState = finishDraft(draft, patches => {\n *   console.log(\"生成的补丁：\", patches)\n * })\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * castDraft - 类型转换：不可变到草稿\n *\n * 这是一个纯类型转换函数（运行时no-op），用于告诉\n * TypeScript将不可变类型视为草稿类型。这在某些\n * 类型推导不准确的场景下很有用。\n *\n * 使用场景：\n * - 类型系统推导不准确时的手动修正\n * - 在复杂的泛型场景中辅助类型推导\n * - 与其他库集成时的类型适配\n *\n * 注意：这只是类型级别的转换，不会改变运行时行为\n *\n * @param value - 要转换类型的值\n * @returns 相同的值，但类型被标记为Draft<T>\n *\n * @example\n * function processState<T>(state: Immutable<T>) {\n *   const draft = castDraft(state)\n *   // 现在TypeScript知道draft是可修改的类型\n *   return draft\n * }\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * castImmutable - 类型转换：草稿到不可变\n *\n * 与castDraft相反，将草稿类型转换为不可变类型。\n * 同样是纯类型转换函数，运行时不执行任何操作。\n *\n * 使用场景：\n * - 确保类型系统认为对象是不可变的\n * - 在API边界处确保类型安全\n * - 与外部库的类型适配\n *\n * @param value - 要转换类型的值\n * @returns 相同的值，但类型被标记为Immutable<T>\n *\n * @example\n * function exportState<T>(draft: Draft<T>): Immutable<T> {\n *   // 确保返回的状态被标记为不可变\n *   return castImmutable(draft)\n * }\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\n/**\n * 导出Immer类本身\n *\n * 允许用户创建自定义配置的Immer实例，用于：\n * - 不同的配置需求（如不同的冻结策略）\n * - 隔离的状态管理（避免全局配置冲突）\n * - 高级定制需求\n */\nexport {Immer}\n\n/**\n * 插件导出\n *\n * 按需启用immer的扩展功能：\n * - enablePatches: 启用补丁系统支持\n * - enableMapSet: 启用Map和Set数据结构支持\n *\n * 插件设计的好处：\n * - 减小核心包体积\n * - 按需加载功能\n * - 更好的tree-shaking支持\n */\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\n"],"mappings":"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","names":["immer","isSet","current","Immer","base","Immer"]}